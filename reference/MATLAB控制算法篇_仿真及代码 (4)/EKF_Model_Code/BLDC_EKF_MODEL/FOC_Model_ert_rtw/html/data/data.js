var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"BLDC_EKF/FOC_Model","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\Jay\\Desktop\\G4\\Simulink\\8.EKF\\BLDC\\BLDC_EKF_MODEL\\FOC_Model_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'FOC_Model'.\r\n *\r\n * Model version                  : 2.183\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sun Oct 22 20:56:15 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"FOC_Model.h\"                 /* Model's header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(rtM, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model for base rate */\r\n  FOC_Model_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example \"main\" function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific.  This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  FOC_Model_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.0001 seconds (the model's base sample time) here.  The\r\n   * call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Disable rt_OneStep here */\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_Model.c","type":"source","group":"model","path":"C:\\Users\\Jay\\Desktop\\G4\\Simulink\\8.EKF\\BLDC\\BLDC_EKF_MODEL\\FOC_Model_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: FOC_Model.c\r\n *\r\n * Code generated for Simulink model 'FOC_Model'.\r\n *\r\n * Model version                  : 2.183\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sun Oct 22 20:56:15 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"FOC_Model.h\"\r\n\r\n/* Named constants for Chart: '<S2>/Chart1' */\r\n#define IN_AlignStage                  ((uint8_T)1U)\r\n#define IN_IDLE                        ((uint8_T)2U)\r\n#define IN_OpenStage                   ((uint8_T)3U)\r\n#define IN_RunStage                    ((uint8_T)4U)\r\n#define IN_ThetaAlign                  ((uint8_T)5U)\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n/* Skipping ulong_long/long_long check: insufficient preprocessor integer range. */\r\n\r\n/* Exported block signals */\r\nreal32_T EKFWm;                        /* '<S2>/Gain1' */\r\nreal32_T EKFTheta;                     /* '<S2>/Mod' */\r\nreal32_T ualpha;                       /* '<S12>/Add' */\r\nreal32_T ubeta;                        /* '<S12>/Add1' */\r\nreal32_T ialpha;                       /* '<S5>/Add1' */\r\nreal32_T ibeta;                        /* '<S5>/Gain2' */\r\nreal32_T state;                        /* '<S2>/Chart1' */\r\n\r\n/* Exported data definition */\r\n\r\n/* Definition for custom storage class: Struct */\r\ncurr_kpki_type curr_kpki = {\r\n  /* curr_d_ki */\r\n  35.0F,\r\n\r\n  /* curr_d_kp */\r\n  0.025F\r\n};\r\n\r\nmotor_type motor = {\r\n  /* L */\r\n  0.00535F,\r\n\r\n  /* Pn */\r\n  4.0F,\r\n\r\n  /* Rs */\r\n  6.97F,\r\n\r\n  /* flux */\r\n  0.016884F\r\n};\r\n\r\nspd_kpki_type spd_kpki = {\r\n  /* spd_ki */\r\n  0.000122904603F,\r\n\r\n  /* spd_kp */\r\n  0.0031514F\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nDW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY rtY;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL rtM_;\r\nRT_MODEL *const rtM = &rtM_;\r\nextern real32_T rt_modf(real32_T u0, real32_T u1);\r\nextern void rt_mrdivide_U1f4x2_U2f2x2_Yf4x2(const real32_T u0[8], const real32_T\r\n  u1[4], real32_T y[8]);\r\nstatic void Clark(real32_T rtu_ia, real32_T rtu_ib, real32_T rtu_ic, real32_T\r\n                  *rty_ialpha, real32_T *rty_ibeta);\r\nstatic void In_park(real32_T rtu_ud, real32_T rtu_uq, real32_T rtu_theta_sin,\r\n                    real32_T rtu_theta_cos, real32_T *rty_ualpha, real32_T\r\n                    *rty_ubeta);\r\nstatic void Park(real32_T rtu_ialpha, real32_T rtu_ibeta, real32_T rtu_theta_sin,\r\n                 real32_T rtu_theta_cos, real32_T *rty_id, real32_T *rty_iq);\r\nstatic void SVPWM1(real32_T rtu_Valpha, real32_T rtu_Vbeta, real32_T rtu_v_bus,\r\n                   real32_T rty_tABC[3]);\r\nstatic void Curr_loop_Init(real_T *rty_RestsSingal, DW_Curr_loop *localDW);\r\nstatic void Curr_loop_Enable(DW_Curr_loop *localDW);\r\nstatic void Curr_loop(RT_MODEL * const rtM, real32_T rtu_ia, real32_T rtu_ib,\r\n                      real32_T rtu_ic, real32_T rtu_MotorOnOff, real32_T\r\n                      rtu_iq_ref, real32_T rtu_VDC, real32_T rty_Tcmp1[3],\r\n                      real32_T *rty_Tcmp2, real32_T *rty_Tcmp3, real32_T\r\n                      *rty_EKFWm, real_T *rty_RestsSingal, const\r\n                      ConstB_Curr_loop *localC, DW_Curr_loop *localDW);\r\nstatic void rate_scheduler(void);\r\n\r\n/*\r\n *         This function updates active task flag for each subrate.\r\n *         The function is called at model base rate, hence the\r\n *         generated code self-manages all its subrates.\r\n */\r\nstatic void rate_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (rtM->Timing.TaskCounters.TID[1])++;\r\n  if ((rtM->Timing.TaskCounters.TID[1]) > 9) {/* Sample time: [0.001s, 0.0s] */\r\n    rtM->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/Clark' */\r\nstatic void Clark(real32_T rtu_ia, real32_T rtu_ib, real32_T rtu_ic, real32_T\r\n                  *rty_ialpha, real32_T *rty_ibeta)\r\n{\r\n  /* Sum: '<S5>/Add1' incorporates:\r\n   *  Gain: '<S5>/Gain'\r\n   *  Gain: '<S5>/Gain1'\r\n   *  Sum: '<S5>/Add'\r\n   */\r\n  *rty_ialpha = 0.666666687F * rtu_ia - (rtu_ib + rtu_ic) * 0.333333343F;\r\n\r\n  /* Gain: '<S5>/Gain2' incorporates:\r\n   *  Sum: '<S5>/Add2'\r\n   */\r\n  *rty_ibeta = (rtu_ib - rtu_ic) * 0.577350259F;\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/In_park' */\r\nstatic void In_park(real32_T rtu_ud, real32_T rtu_uq, real32_T rtu_theta_sin,\r\n                    real32_T rtu_theta_cos, real32_T *rty_ualpha, real32_T\r\n                    *rty_ubeta)\r\n{\r\n  /* Sum: '<S12>/Add' incorporates:\r\n   *  Product: '<S12>/Product'\r\n   *  Product: '<S12>/Product1'\r\n   */\r\n  *rty_ualpha = rtu_ud * rtu_theta_cos - rtu_uq * rtu_theta_sin;\r\n\r\n  /* Sum: '<S12>/Add1' incorporates:\r\n   *  Product: '<S12>/Product2'\r\n   *  Product: '<S12>/Product3'\r\n   */\r\n  *rty_ubeta = rtu_ud * rtu_theta_sin + rtu_uq * rtu_theta_cos;\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/Park' */\r\nstatic void Park(real32_T rtu_ialpha, real32_T rtu_ibeta, real32_T rtu_theta_sin,\r\n                 real32_T rtu_theta_cos, real32_T *rty_id, real32_T *rty_iq)\r\n{\r\n  /* Sum: '<S13>/Add' incorporates:\r\n   *  Product: '<S13>/Product'\r\n   *  Product: '<S13>/Product1'\r\n   */\r\n  *rty_id = rtu_ialpha * rtu_theta_cos + rtu_ibeta * rtu_theta_sin;\r\n\r\n  /* Sum: '<S13>/Add1' incorporates:\r\n   *  Product: '<S13>/Product2'\r\n   *  Product: '<S13>/Product3'\r\n   */\r\n  *rty_iq = rtu_ibeta * rtu_theta_cos - rtu_ialpha * rtu_theta_sin;\r\n}\r\n\r\n/* Output and update for atomic system: '<S2>/SVPWM1' */\r\nstatic void SVPWM1(real32_T rtu_Valpha, real32_T rtu_Vbeta, real32_T rtu_v_bus,\r\n                   real32_T rty_tABC[3])\r\n{\r\n  real32_T rtb_Min;\r\n  real32_T rtb_Sum1_j;\r\n  real32_T rtb_Sum_b;\r\n\r\n  /* Gain: '<S28>/Gain' */\r\n  rtb_Min = -0.5F * rtu_Valpha;\r\n\r\n  /* Gain: '<S28>/Gain1' */\r\n  rtb_Sum1_j = 0.866025388F * rtu_Vbeta;\r\n\r\n  /* Sum: '<S28>/Sum' */\r\n  rtb_Sum_b = rtb_Min + rtb_Sum1_j;\r\n\r\n  /* Sum: '<S28>/Sum1' */\r\n  rtb_Sum1_j = rtb_Min - rtb_Sum1_j;\r\n\r\n  /* Gain: '<S29>/Gain' incorporates:\r\n   *  MinMax: '<S29>/Min'\r\n   *  MinMax: '<S29>/Min1'\r\n   *  Sum: '<S29>/Sum'\r\n   */\r\n  rtb_Min = (fminf(fminf(rtu_Valpha, rtb_Sum_b), rtb_Sum1_j) + fmaxf(fmaxf\r\n              (rtu_Valpha, rtb_Sum_b), rtb_Sum1_j)) * -0.5F;\r\n\r\n  /* Gain: '<S14>/PWM_HalfPeriod' incorporates:\r\n   *  Constant: '<S14>/Constant'\r\n   *  Gain: '<S14>/Gain'\r\n   *  Product: '<S14>/Divide'\r\n   *  Sum: '<S14>/Sum'\r\n   *  Sum: '<S14>/Sum1'\r\n   */\r\n  rty_tABC[0] = (-(rtb_Min + rtu_Valpha) / rtu_v_bus + 0.5F) * 8000.0F;\r\n  rty_tABC[1] = (-(rtb_Min + rtb_Sum_b) / rtu_v_bus + 0.5F) * 8000.0F;\r\n  rty_tABC[2] = (-(rtb_Min + rtb_Sum1_j) / rtu_v_bus + 0.5F) * 8000.0F;\r\n}\r\n\r\nreal32_T rt_modf(real32_T u0, real32_T u1)\r\n{\r\n  real32_T y;\r\n  y = u0;\r\n  if (u1 == 0.0F) {\r\n    if (u0 == 0.0F) {\r\n      y = u1;\r\n    }\r\n  } else if (u0 == 0.0F) {\r\n    y = 0.0F / u1;\r\n  } else {\r\n    boolean_T yEq;\r\n    y = fmodf(u0, u1);\r\n    yEq = (y == 0.0F);\r\n    if ((!yEq) && (u1 > floorf(u1))) {\r\n      real32_T q;\r\n      q = fabsf(u0 / u1);\r\n      yEq = (fabsf(q - floorf(q + 0.5F)) <= FLT_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = 0.0F;\r\n    } else if ((u0 < 0.0F) != (u1 < 0.0F)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nvoid rt_mrdivide_U1f4x2_U2f2x2_Yf4x2(const real32_T u0[8], const real32_T u1[4],\r\n  real32_T y[8])\r\n{\r\n  int32_T r1;\r\n  int32_T r2;\r\n  int32_T y_tmp;\r\n  real32_T a21;\r\n  real32_T a22;\r\n  real32_T a22_tmp;\r\n  if (fabsf(u1[1]) > fabsf(u1[0])) {\r\n    r1 = 1;\r\n    r2 = 0;\r\n  } else {\r\n    r1 = 0;\r\n    r2 = 1;\r\n  }\r\n\r\n  a21 = u1[r2] / u1[r1];\r\n  a22_tmp = u1[r1 + 2];\r\n  a22 = u1[r2 + 2] - a22_tmp * a21;\r\n  y_tmp = r1 << 2;\r\n  y[y_tmp] = u0[0] / u1[r1];\r\n  r2 <<= 2;\r\n  y[r2] = (u0[4] - y[y_tmp] * a22_tmp) / a22;\r\n  y[y_tmp] -= y[r2] * a21;\r\n  y[y_tmp + 1] = u0[1] / u1[r1];\r\n  y[r2 + 1] = (u0[5] - y[y_tmp + 1] * a22_tmp) / a22;\r\n  y[y_tmp + 1] -= y[r2 + 1] * a21;\r\n  y[y_tmp + 2] = u0[2] / u1[r1];\r\n  y[r2 + 2] = (u0[6] - y[y_tmp + 2] * a22_tmp) / a22;\r\n  y[y_tmp + 2] -= y[r2 + 2] * a21;\r\n  y[y_tmp + 3] = u0[3] / u1[r1];\r\n  y[r2 + 3] = (u0[7] - y[y_tmp + 3] * a22_tmp) / a22;\r\n  y[y_tmp + 3] -= y[r2 + 3] * a21;\r\n}\r\n\r\n/* System initialize for function-call system: '<S1>/Curr_loop' */\r\nstatic void Curr_loop_Init(real_T *rty_RestsSingal, DW_Curr_loop *localDW)\r\n{\r\n  /* Start for SwitchCase: '<S2>/Switch Case1' */\r\n  localDW->SwitchCase1_ActiveSubsystem = -1;\r\n\r\n  /* SystemInitialize for Chart: '<S2>/Chart1' */\r\n  *rty_RestsSingal = 0.0;\r\n\r\n  /* SystemInitialize for IfAction SubSystem: '<S2>/If Action Subsystem2' */\r\n  /* InitializeConditions for DiscreteIntegrator: '<S9>/Discrete-Time Integrator' */\r\n  localDW->DiscreteTimeIntegrator_PrevRese = 2;\r\n\r\n  /* InitializeConditions for DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n  localDW->DiscreteTimeIntegrator1_PrevRes = 2;\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S2>/If Action Subsystem2' */\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<S2>/EKF' */\r\n  /* Start for IdentityMatrix: '<S16>/IdentityMatrix' */\r\n  memcpy(&localDW->IdentityMatrix[0], &rtConstP.pooled4[0], sizeof(real32_T) <<\r\n         4U);\r\n\r\n  /* Start for IdentityMatrix: '<S19>/IdentityMatrix' */\r\n  memcpy(&localDW->IdentityMatrix_k[0], &rtConstP.pooled4[0], sizeof(real32_T) <<\r\n         4U);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S2>/EKF' */\r\n}\r\n\r\n/* Enable for function-call system: '<S1>/Curr_loop' */\r\nstatic void Curr_loop_Enable(DW_Curr_loop *localDW)\r\n{\r\n  localDW->Curr_loop_RESET_ELAPS_T = true;\r\n\r\n  /* Enable for DiscreteIntegrator: '<S65>/Integrator' */\r\n  localDW->Integrator_SYSTEM_ENABLE = 1U;\r\n\r\n  /* Enable for DiscreteIntegrator: '<S115>/Integrator' */\r\n  localDW->Integrator_SYSTEM_ENABLE_e = 1U;\r\n}\r\n\r\n/* Output and update for function-call system: '<S1>/Curr_loop' */\r\nstatic void Curr_loop(RT_MODEL * const rtM, real32_T rtu_ia, real32_T rtu_ib,\r\n                      real32_T rtu_ic, real32_T rtu_MotorOnOff, real32_T\r\n                      rtu_iq_ref, real32_T rtu_VDC, real32_T rty_Tcmp1[3],\r\n                      real32_T *rty_Tcmp2, real32_T *rty_Tcmp3, real32_T\r\n                      *rty_EKFWm, real_T *rty_RestsSingal, const\r\n                      ConstB_Curr_loop *localC, DW_Curr_loop *localDW)\r\n{\r\n  int32_T i;\r\n  int32_T i_0;\r\n  int32_T rtb_Transpose_tmp;\r\n  int32_T rtb_Transpose_tmp_tmp;\r\n  real32_T rtb_Add_i[16];\r\n  real32_T rtb_Transpose[16];\r\n  real32_T rtb_Transpose_0[16];\r\n  real32_T rtb_Divide[8];\r\n  real32_T rtb_Add1[4];\r\n  real32_T rtb_Add_n[4];\r\n  real32_T rtb_MatrixMultiply_d[4];\r\n  real32_T rtb_VectorConcatenate1[4];\r\n  real32_T rtb_VectorConcatenate4[4];\r\n  real32_T rtb_VectorConcatenate[2];\r\n  real32_T tmp[2];\r\n  real32_T tmp_0[2];\r\n  real32_T DiscreteTimeIntegrator;\r\n  real32_T DiscreteTimeIntegrator1_n;\r\n  real32_T DiscreteTimeIntegrator1_n_0;\r\n  real32_T Integrator;\r\n  real32_T rtb_Add_l_tmp;\r\n  real32_T rtb_Add_l_tmp_0;\r\n  real32_T rtb_Cos;\r\n  real32_T rtb_IProdOut;\r\n  real32_T rtb_SignPreIntegrator_bb;\r\n  real32_T rtb_Sin;\r\n  real32_T rtb_Sum1;\r\n  uint32_T Curr_loop_ELAPS_T;\r\n  uint32_T Curr_loop_PREV_T_tmp;\r\n  int16_T Integrator_g;\r\n  int16_T rtb_IProdOut_p;\r\n  int8_T rtAction;\r\n  int8_T rtPrevAction;\r\n  if (localDW->Curr_loop_RESET_ELAPS_T) {\r\n    Curr_loop_ELAPS_T = 0U;\r\n  } else {\r\n    Curr_loop_ELAPS_T = rtM->Timing.clockTick0 - localDW->Curr_loop_PREV_T;\r\n  }\r\n\r\n  /* Update for IfAction SubSystem: '<S2>/If Action Subsystem4' incorporates:\r\n   *  ActionPort: '<S11>/Action Port'\r\n   */\r\n  /* Update for IfAction SubSystem: '<S2>/If Action Subsystem2' incorporates:\r\n   *  ActionPort: '<S9>/Action Port'\r\n   */\r\n  /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem4' incorporates:\r\n   *  ActionPort: '<S11>/Action Port'\r\n   */\r\n  /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem2' incorporates:\r\n   *  ActionPort: '<S9>/Action Port'\r\n   */\r\n  /* SwitchCase: '<S2>/Switch Case1' */\r\n  Curr_loop_PREV_T_tmp = rtM->Timing.clockTick0;\r\n\r\n  /* End of Outputs for SubSystem: '<S2>/If Action Subsystem2' */\r\n  /* End of Outputs for SubSystem: '<S2>/If Action Subsystem4' */\r\n  /* End of Update for SubSystem: '<S2>/If Action Subsystem2' */\r\n  /* End of Update for SubSystem: '<S2>/If Action Subsystem4' */\r\n  localDW->Curr_loop_PREV_T = Curr_loop_PREV_T_tmp;\r\n  localDW->Curr_loop_RESET_ELAPS_T = false;\r\n\r\n  /* Chart: '<S2>/Chart1' */\r\n  if (localDW->temporalCounter_i1 < 32767U) {\r\n    localDW->temporalCounter_i1++;\r\n  }\r\n\r\n  if (localDW->is_active_c7_FOC_Model == 0U) {\r\n    localDW->is_active_c7_FOC_Model = 1U;\r\n    localDW->is_c7_FOC_Model = IN_IDLE;\r\n  } else {\r\n    switch (localDW->is_c7_FOC_Model) {\r\n     case IN_AlignStage:\r\n      if (localDW->temporalCounter_i1 >= 1000) {\r\n        localDW->is_c7_FOC_Model = IN_OpenStage;\r\n        localDW->temporalCounter_i1 = 0U;\r\n        localDW->ZReset = 0.0F;\r\n        localDW->cnt = 0.0F;\r\n      } else if (rtu_MotorOnOff == 0.0F) {\r\n        localDW->is_c7_FOC_Model = IN_IDLE;\r\n      } else {\r\n        state = 2.0F;\r\n        *rty_RestsSingal = 0.0;\r\n      }\r\n      break;\r\n\r\n     case IN_IDLE:\r\n      if (rtu_MotorOnOff == 1.0F) {\r\n        localDW->is_c7_FOC_Model = IN_AlignStage;\r\n        localDW->temporalCounter_i1 = 0U;\r\n      } else {\r\n        state = 1.0F;\r\n        *rty_RestsSingal = 0.0;\r\n      }\r\n      break;\r\n\r\n     case IN_OpenStage:\r\n      if (rtu_MotorOnOff == 0.0F) {\r\n        localDW->is_c7_FOC_Model = IN_IDLE;\r\n      } else if (localDW->temporalCounter_i1 >= 30000) {\r\n        localDW->is_c7_FOC_Model = IN_ThetaAlign;\r\n        localDW->temporalCounter_i1 = 0U;\r\n      } else {\r\n        if (localDW->cnt == 1.0F) {\r\n          localDW->ZReset = 1.0F;\r\n        }\r\n\r\n        localDW->cnt = 1.0F;\r\n        state = 3.0F;\r\n        *rty_RestsSingal = 0.0;\r\n      }\r\n      break;\r\n\r\n     case IN_RunStage:\r\n      if (rtu_MotorOnOff == 0.0F) {\r\n        localDW->is_c7_FOC_Model = IN_IDLE;\r\n      } else {\r\n        state = 5.0F;\r\n        *rty_RestsSingal = 1.0;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_ThetaAlign: */\r\n      if (localDW->temporalCounter_i1 >= 5000) {\r\n        localDW->is_c7_FOC_Model = IN_RunStage;\r\n      } else {\r\n        state = 4.0F;\r\n        *rty_RestsSingal = 0.0;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S2>/Chart1' */\r\n\r\n  /* Outputs for Atomic SubSystem: '<S2>/Clark' */\r\n  Clark(rtu_ia, rtu_ib, rtu_ic, &ialpha, &ibeta);\r\n\r\n  /* End of Outputs for SubSystem: '<S2>/Clark' */\r\n\r\n  /* SwitchCase: '<S2>/Switch Case1' */\r\n  rtPrevAction = localDW->SwitchCase1_ActiveSubsystem;\r\n  rtAction = -1;\r\n  switch ((int32_T)state) {\r\n   case 1:\r\n    rtAction = 0;\r\n    break;\r\n\r\n   case 2:\r\n    rtAction = 1;\r\n    break;\r\n\r\n   case 3:\r\n    rtAction = 2;\r\n    break;\r\n\r\n   case 4:\r\n    rtAction = 3;\r\n    break;\r\n\r\n   case 5:\r\n    rtAction = 4;\r\n    break;\r\n  }\r\n\r\n  localDW->SwitchCase1_ActiveSubsystem = rtAction;\r\n  switch (rtAction) {\r\n   case 0:\r\n    /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem' incorporates:\r\n     *  ActionPort: '<S7>/Action Port'\r\n     */\r\n    /* Merge: '<S2>/Merge' incorporates:\r\n     *  Constant: '<S7>/Constant'\r\n     *  SignalConversion generated from: '<S7>/theta_fd'\r\n     */\r\n    localDW->Merge = 0.0F;\r\n\r\n    /* Merge: '<S2>/Merge1' incorporates:\r\n     *  Constant: '<S7>/Constant1'\r\n     *  SignalConversion generated from: '<S7>/iq_ref'\r\n     */\r\n    localDW->Merge1 = 0.0F;\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/If Action Subsystem' */\r\n    break;\r\n\r\n   case 1:\r\n    /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem1' incorporates:\r\n     *  ActionPort: '<S8>/Action Port'\r\n     */\r\n    /* Merge: '<S2>/Merge' incorporates:\r\n     *  Constant: '<S8>/Constant'\r\n     *  SignalConversion generated from: '<S8>/theta_fd'\r\n     */\r\n    localDW->Merge = 0.0F;\r\n\r\n    /* Merge: '<S2>/Merge1' incorporates:\r\n     *  Constant: '<S8>/Constant1'\r\n     *  SignalConversion generated from: '<S8>/iq_ref'\r\n     */\r\n    localDW->Merge1 = 0.3F;\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/If Action Subsystem1' */\r\n    break;\r\n\r\n   case 2:\r\n    {\r\n      uint32_T IfActionSubsystem2_ELAPS_T;\r\n      if (rtAction != rtPrevAction) {\r\n        localDW->IfActionSubsystem2_RESET_ELAPS_ = true;\r\n\r\n        /* Enable for IfAction SubSystem: '<S2>/If Action Subsystem2' incorporates:\r\n         *  ActionPort: '<S9>/Action Port'\r\n         */\r\n        /* Enable for SwitchCase: '<S2>/Switch Case1' incorporates:\r\n         *  DiscreteIntegrator: '<S9>/Discrete-Time Integrator'\r\n         *  DiscreteIntegrator: '<S9>/Discrete-Time Integrator1'\r\n         */\r\n        localDW->DiscreteTimeIntegrator_SYSTEM_E = 1U;\r\n        localDW->DiscreteTimeIntegrator1_SYSTE_f = 1U;\r\n\r\n        /* End of Enable for SubSystem: '<S2>/If Action Subsystem2' */\r\n      }\r\n\r\n      /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem2' incorporates:\r\n       *  ActionPort: '<S9>/Action Port'\r\n       */\r\n      if (localDW->IfActionSubsystem2_RESET_ELAPS_) {\r\n        IfActionSubsystem2_ELAPS_T = 0U;\r\n      } else {\r\n        IfActionSubsystem2_ELAPS_T = Curr_loop_PREV_T_tmp -\r\n          localDW->IfActionSubsystem2_PREV_T;\r\n      }\r\n\r\n      localDW->IfActionSubsystem2_PREV_T = Curr_loop_PREV_T_tmp;\r\n      localDW->IfActionSubsystem2_RESET_ELAPS_ = false;\r\n\r\n      /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator' */\r\n      if (localDW->DiscreteTimeIntegrator_SYSTEM_E != 0) {\r\n        /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator' */\r\n        DiscreteTimeIntegrator = localDW->DiscreteTimeIntegrator_DSTATE;\r\n      } else if ((localDW->ZReset > 0.0F) &&\r\n                 (localDW->DiscreteTimeIntegrator_PrevRese <= 0)) {\r\n        localDW->DiscreteTimeIntegrator_DSTATE = 0.0F;\r\n\r\n        /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator' */\r\n        DiscreteTimeIntegrator = localDW->DiscreteTimeIntegrator_DSTATE;\r\n      } else {\r\n        /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator' */\r\n        DiscreteTimeIntegrator = 0.0001F * (real32_T)IfActionSubsystem2_ELAPS_T *\r\n          localDW->DiscreteTimeIntegrator_PREV_U +\r\n          localDW->DiscreteTimeIntegrator_DSTATE;\r\n      }\r\n\r\n      /* End of DiscreteIntegrator: '<S9>/Discrete-Time Integrator' */\r\n\r\n      /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n      if (localDW->DiscreteTimeIntegrator1_SYSTE_f != 0) {\r\n        /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n        DiscreteTimeIntegrator1_n = localDW->DiscreteTimeIntegrator1_DSTAT_j;\r\n      } else if ((localDW->ZReset > 0.0F) &&\r\n                 (localDW->DiscreteTimeIntegrator1_PrevRes <= 0)) {\r\n        localDW->DiscreteTimeIntegrator1_DSTAT_j = 0.0F;\r\n\r\n        /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n        DiscreteTimeIntegrator1_n = localDW->DiscreteTimeIntegrator1_DSTAT_j;\r\n      } else {\r\n        /* DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n        DiscreteTimeIntegrator1_n = 0.0001F * (real32_T)\r\n          IfActionSubsystem2_ELAPS_T * localDW->DiscreteTimeIntegrator1_PREV__h\r\n          + localDW->DiscreteTimeIntegrator1_DSTAT_j;\r\n      }\r\n\r\n      /* End of DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n\r\n      /* Merge: '<S2>/Merge' incorporates:\r\n       *  Constant: '<S9>/Constant'\r\n       *  Math: '<S9>/Mod'\r\n       */\r\n      localDW->Merge = rt_modf(DiscreteTimeIntegrator1_n, 6.28318548F);\r\n\r\n      /* Merge: '<S2>/Merge1' incorporates:\r\n       *  Constant: '<S9>/Constant2'\r\n       *  SignalConversion generated from: '<S9>/iq_ref'\r\n       */\r\n      localDW->Merge1 = 0.3F;\r\n\r\n      /* Update for DiscreteIntegrator: '<S9>/Discrete-Time Integrator' incorporates:\r\n       *  Gain: '<S9>/Gain'\r\n       *  Product: '<S9>/Product'\r\n       */\r\n      localDW->DiscreteTimeIntegrator_SYSTEM_E = 0U;\r\n      localDW->DiscreteTimeIntegrator_DSTATE = DiscreteTimeIntegrator;\r\n      if (localDW->ZReset > 0.0F) {\r\n        localDW->DiscreteTimeIntegrator_PrevRese = 1;\r\n      } else if (localDW->ZReset < 0.0F) {\r\n        localDW->DiscreteTimeIntegrator_PrevRese = -1;\r\n      } else if (localDW->ZReset == 0.0F) {\r\n        localDW->DiscreteTimeIntegrator_PrevRese = 0;\r\n      } else {\r\n        localDW->DiscreteTimeIntegrator_PrevRese = 2;\r\n      }\r\n\r\n      localDW->DiscreteTimeIntegrator_PREV_U = motor.Pn * 31.4159279F *\r\n        0.333333343F;\r\n\r\n      /* End of Update for DiscreteIntegrator: '<S9>/Discrete-Time Integrator' */\r\n\r\n      /* Update for DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n      localDW->DiscreteTimeIntegrator1_SYSTE_f = 0U;\r\n      localDW->DiscreteTimeIntegrator1_DSTAT_j = DiscreteTimeIntegrator1_n;\r\n      if (localDW->ZReset > 0.0F) {\r\n        localDW->DiscreteTimeIntegrator1_PrevRes = 1;\r\n      } else if (localDW->ZReset < 0.0F) {\r\n        localDW->DiscreteTimeIntegrator1_PrevRes = -1;\r\n      } else if (localDW->ZReset == 0.0F) {\r\n        localDW->DiscreteTimeIntegrator1_PrevRes = 0;\r\n      } else {\r\n        localDW->DiscreteTimeIntegrator1_PrevRes = 2;\r\n      }\r\n\r\n      localDW->DiscreteTimeIntegrator1_PREV__h = DiscreteTimeIntegrator;\r\n\r\n      /* End of Update for DiscreteIntegrator: '<S9>/Discrete-Time Integrator1' */\r\n      /* End of Outputs for SubSystem: '<S2>/If Action Subsystem2' */\r\n    }\r\n    break;\r\n\r\n   case 3:\r\n    {\r\n      uint32_T IfActionSubsystem2_ELAPS_T;\r\n      if (rtAction != rtPrevAction) {\r\n        localDW->IfActionSubsystem4_RESET_ELAPS_ = true;\r\n\r\n        /* Enable for IfAction SubSystem: '<S2>/If Action Subsystem4' incorporates:\r\n         *  ActionPort: '<S11>/Action Port'\r\n         */\r\n        /* Enable for SwitchCase: '<S2>/Switch Case1' incorporates:\r\n         *  DiscreteIntegrator: '<S11>/Discrete-Time Integrator1'\r\n         */\r\n        localDW->DiscreteTimeIntegrator1_SYSTEM_ = 1U;\r\n\r\n        /* End of Enable for SubSystem: '<S2>/If Action Subsystem4' */\r\n      }\r\n\r\n      /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem4' incorporates:\r\n       *  ActionPort: '<S11>/Action Port'\r\n       */\r\n      if (localDW->IfActionSubsystem4_RESET_ELAPS_) {\r\n        IfActionSubsystem2_ELAPS_T = 0U;\r\n      } else {\r\n        IfActionSubsystem2_ELAPS_T = Curr_loop_PREV_T_tmp -\r\n          localDW->IfActionSubsystem4_PREV_T;\r\n      }\r\n\r\n      localDW->IfActionSubsystem4_PREV_T = Curr_loop_PREV_T_tmp;\r\n      localDW->IfActionSubsystem4_RESET_ELAPS_ = false;\r\n\r\n      /* DiscreteIntegrator: '<S11>/Discrete-Time Integrator1' */\r\n      if (localDW->DiscreteTimeIntegrator1_SYSTEM_ != 0) {\r\n        /* DiscreteIntegrator: '<S11>/Discrete-Time Integrator1' */\r\n        DiscreteTimeIntegrator = localDW->DiscreteTimeIntegrator1_DSTATE;\r\n      } else {\r\n        /* DiscreteIntegrator: '<S11>/Discrete-Time Integrator1' */\r\n        DiscreteTimeIntegrator = 0.0001F * (real32_T)IfActionSubsystem2_ELAPS_T *\r\n          localDW->DiscreteTimeIntegrator1_PREV_U +\r\n          localDW->DiscreteTimeIntegrator1_DSTATE;\r\n      }\r\n\r\n      /* End of DiscreteIntegrator: '<S11>/Discrete-Time Integrator1' */\r\n\r\n      /* Merge: '<S2>/Merge' incorporates:\r\n       *  Constant: '<S11>/Constant'\r\n       *  Math: '<S11>/Mod'\r\n       *  SignalConversion generated from: '<S11>/Theta_fd'\r\n       */\r\n      localDW->Merge = rt_modf(DiscreteTimeIntegrator, 6.28318548F);\r\n\r\n      /* If: '<S11>/If' incorporates:\r\n       *  Constant: '<S11>/Constant1'\r\n       *  Constant: '<S24>/Constant'\r\n       *  SignalConversion generated from: '<S24>/Out1'\r\n       *  Sum: '<S11>/Add'\r\n       *  UnitDelay: '<S11>/Unit Delay'\r\n       */\r\n      if (localDW->UnitDelay_DSTATE + 0.01F >= 1.0F) {\r\n        /* Outputs for IfAction SubSystem: '<S11>/If Action Subsystem' incorporates:\r\n         *  ActionPort: '<S24>/Action Port'\r\n         */\r\n        rtb_IProdOut = 1.0F;\r\n\r\n        /* End of Outputs for SubSystem: '<S11>/If Action Subsystem' */\r\n      } else {\r\n        rtb_IProdOut = localDW->UnitDelay_DSTATE + 0.01F;\r\n      }\r\n\r\n      /* End of If: '<S11>/If' */\r\n\r\n      /* Merge: '<S2>/Merge1' incorporates:\r\n       *  Constant: '<S11>/Constant2'\r\n       *  Constant: '<S11>/Constant4'\r\n       *  Product: '<S11>/Product1'\r\n       *  Sum: '<S11>/Add4'\r\n       */\r\n      localDW->Merge1 = 0.3F - rtb_IProdOut * 0.05F;\r\n\r\n      /* Update for DiscreteIntegrator: '<S11>/Discrete-Time Integrator1' incorporates:\r\n       *  Gain: '<S11>/Gain'\r\n       */\r\n      localDW->DiscreteTimeIntegrator1_SYSTEM_ = 0U;\r\n      localDW->DiscreteTimeIntegrator1_DSTATE = DiscreteTimeIntegrator;\r\n      localDW->DiscreteTimeIntegrator1_PREV_U = motor.Pn * 31.4159279F;\r\n\r\n      /* Update for UnitDelay: '<S11>/Unit Delay' incorporates:\r\n       *  Constant: '<S11>/Constant1'\r\n       *  Sum: '<S11>/Add'\r\n       */\r\n      localDW->UnitDelay_DSTATE += 0.01F;\r\n\r\n      /* End of Outputs for SubSystem: '<S2>/If Action Subsystem4' */\r\n    }\r\n    break;\r\n\r\n   case 4:\r\n    /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem3' incorporates:\r\n     *  ActionPort: '<S10>/Action Port'\r\n     */\r\n    /* Merge: '<S2>/Merge' incorporates:\r\n     *  Inport: '<S10>/theta_Close'\r\n     *  UnitDelay: '<S2>/Unit Delay1'\r\n     */\r\n    localDW->Merge = EKFTheta;\r\n\r\n    /* Merge: '<S2>/Merge1' incorporates:\r\n     *  Inport: '<S10>/iq_CloseRef'\r\n     */\r\n    localDW->Merge1 = rtu_iq_ref;\r\n\r\n    /* End of Outputs for SubSystem: '<S2>/If Action Subsystem3' */\r\n    break;\r\n  }\r\n\r\n  /* Trigonometry: '<S2>/Cos' */\r\n  rtb_Cos = arm_cos_f32(localDW->Merge);\r\n\r\n  /* Trigonometry: '<S2>/Sin' */\r\n  rtb_Sin = arm_sin_f32(localDW->Merge);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S2>/Park' */\r\n  Park(ialpha, ibeta, rtb_Sin, rtb_Cos, &rtb_SignPreIntegrator_bb,\r\n       &DiscreteTimeIntegrator);\r\n\r\n  /* End of Outputs for SubSystem: '<S2>/Park' */\r\n\r\n  /* Sum: '<S15>/Sum1' incorporates:\r\n   *  Constant: '<S15>/Constant'\r\n   */\r\n  rtb_Sum1 = 0.0F - rtb_SignPreIntegrator_bb;\r\n\r\n  /* DiscreteIntegrator: '<S65>/Integrator' */\r\n  if (localDW->Integrator_SYSTEM_ENABLE != 0) {\r\n    /* DiscreteIntegrator: '<S65>/Integrator' */\r\n    Integrator_g = localDW->Integrator_DSTATE_f;\r\n  } else {\r\n    /* DiscreteIntegrator: '<S65>/Integrator' */\r\n    Integrator_g = (int16_T)((int16_T)((int32_T)Curr_loop_ELAPS_T\r\n      * localDW->Integrator_PREV_U_l) + localDW->Integrator_DSTATE_f);\r\n  }\r\n\r\n  /* End of DiscreteIntegrator: '<S65>/Integrator' */\r\n\r\n  /* Sum: '<S74>/Sum' incorporates:\r\n   *  Constant: '<S15>/Constant'\r\n   *  Constant: '<S15>/Constant3'\r\n   *  DiscreteIntegrator: '<S65>/Integrator'\r\n   *  Product: '<S70>/PProd Out'\r\n   *  Sum: '<S15>/Sum1'\r\n   */\r\n  DiscreteTimeIntegrator1_n = (0.0F - rtb_SignPreIntegrator_bb) *\r\n    curr_kpki.curr_d_kp + (real32_T)Integrator_g * 0.0001F;\r\n\r\n  /* Sum: '<S15>/Sum7' */\r\n  rtb_IProdOut = localDW->Merge1 - DiscreteTimeIntegrator;\r\n\r\n  /* DiscreteIntegrator: '<S115>/Integrator' */\r\n  if (localDW->Integrator_SYSTEM_ENABLE_e != 0) {\r\n    /* DiscreteIntegrator: '<S115>/Integrator' */\r\n    Integrator = localDW->Integrator_DSTATE;\r\n  } else {\r\n    /* DiscreteIntegrator: '<S115>/Integrator' */\r\n    Integrator = 0.0001F * (real32_T)Curr_loop_ELAPS_T\r\n      * localDW->Integrator_PREV_U + localDW->Integrator_DSTATE;\r\n  }\r\n\r\n  /* End of DiscreteIntegrator: '<S115>/Integrator' */\r\n\r\n  /* Sum: '<S124>/Sum' incorporates:\r\n   *  Constant: '<S15>/Constant1'\r\n   *  Product: '<S120>/PProd Out'\r\n   */\r\n  DiscreteTimeIntegrator = rtb_IProdOut * curr_kpki.curr_d_kp + Integrator;\r\n\r\n  /* Saturate: '<S72>/Saturation' */\r\n  if (DiscreteTimeIntegrator1_n > 12.4707661F) {\r\n    DiscreteTimeIntegrator1_n_0 = 12.4707661F;\r\n  } else if (DiscreteTimeIntegrator1_n < -12.4707661F) {\r\n    DiscreteTimeIntegrator1_n_0 = -12.4707661F;\r\n  } else {\r\n    DiscreteTimeIntegrator1_n_0 = DiscreteTimeIntegrator1_n;\r\n  }\r\n\r\n  /* End of Saturate: '<S72>/Saturation' */\r\n\r\n  /* Saturate: '<S122>/Saturation' */\r\n  if (DiscreteTimeIntegrator > 12.4707661F) {\r\n    rtb_SignPreIntegrator_bb = 12.4707661F;\r\n  } else if (DiscreteTimeIntegrator < -12.4707661F) {\r\n    rtb_SignPreIntegrator_bb = -12.4707661F;\r\n  } else {\r\n    rtb_SignPreIntegrator_bb = DiscreteTimeIntegrator;\r\n  }\r\n\r\n  /* End of Saturate: '<S122>/Saturation' */\r\n\r\n  /* Outputs for Atomic SubSystem: '<S2>/In_park' */\r\n  In_park(DiscreteTimeIntegrator1_n_0, rtb_SignPreIntegrator_bb, rtb_Sin,\r\n          rtb_Cos, &ualpha, &ubeta);\r\n\r\n  /* End of Outputs for SubSystem: '<S2>/In_park' */\r\n\r\n  /* Outputs for Atomic SubSystem: '<S2>/EKF' */\r\n  /* Trigonometry: '<S17>/Cos1' incorporates:\r\n   *  Delay: '<S6>/Delay7'\r\n   */\r\n  rtb_Cos = sinf(localDW->Delay7_DSTATE);\r\n\r\n  /* Trigonometry: '<S17>/Cos' incorporates:\r\n   *  Delay: '<S6>/Delay7'\r\n   */\r\n  rtb_SignPreIntegrator_bb = cosf(localDW->Delay7_DSTATE);\r\n\r\n  /* Gain: '<S23>/Gain4' incorporates:\r\n   *  Constant: '<S17>/Constant6'\r\n   *  Gain: '<S23>/Gain5'\r\n   */\r\n  DiscreteTimeIntegrator1_n_0 = -motor.Rs / motor.L;\r\n\r\n  /* Product: '<S16>/Matrix Multiply' incorporates:\r\n   *  Constant: '<S17>/Constant6'\r\n   */\r\n  rtb_Sin = DiscreteTimeIntegrator1_n_0 * 0.0001F;\r\n\r\n  /* Sum: '<S16>/Add1' incorporates:\r\n   *  Concatenate: '<S17>/Matrix Concatenate'\r\n   *  Constant: '<S17>/Constant4'\r\n   *  Constant: '<S17>/Constant5'\r\n   *  Product: '<S16>/Matrix Multiply'\r\n   */\r\n  rtb_Add_i[0] = rtb_Sin;\r\n  rtb_Add_i[1] = 0.0F;\r\n  rtb_Add_i[2] = 0.0F;\r\n  rtb_Add_i[3] = 0.0F;\r\n  rtb_Add_i[4] = 0.0F;\r\n  rtb_Add_i[5] = rtb_Sin;\r\n  rtb_Add_i[6] = 0.0F;\r\n  rtb_Add_i[7] = 0.0F;\r\n\r\n  /* Gain: '<S17>/Gain4' incorporates:\r\n   *  Gain: '<S17>/Gain1'\r\n   *  Gain: '<S23>/Gain2'\r\n   */\r\n  rtb_Sin = motor.flux / motor.L;\r\n\r\n  /* Sum: '<S16>/Add1' incorporates:\r\n   *  Concatenate: '<S17>/Matrix Concatenate'\r\n   *  Gain: '<S17>/Gain4'\r\n   *  Product: '<S16>/Matrix Multiply'\r\n   */\r\n  rtb_Add_i[8] = rtb_Sin * rtb_Cos * 0.0001F;\r\n\r\n  /* Gain: '<S17>/Gain3' incorporates:\r\n   *  Gain: '<S23>/Gain1'\r\n   */\r\n  rtb_Add_l_tmp_0 = -motor.flux / motor.L;\r\n\r\n  /* Sum: '<S16>/Add1' incorporates:\r\n   *  Concatenate: '<S17>/Matrix Concatenate'\r\n   *  Constant: '<S17>/Constant4'\r\n   *  Constant: '<S17>/Constant5'\r\n   *  Gain: '<S17>/Gain3'\r\n   *  Product: '<S16>/Matrix Multiply'\r\n   */\r\n  rtb_Add_i[9] = rtb_Add_l_tmp_0 * rtb_SignPreIntegrator_bb * 0.0001F;\r\n  rtb_Add_i[10] = 0.0F;\r\n  rtb_Add_i[11] = 0.0001F;\r\n\r\n  /* Gain: '<S17>/Gain1' incorporates:\r\n   *  Delay: '<S6>/Delay6'\r\n   *  Gain: '<S17>/Gain2'\r\n   */\r\n  rtb_Add_l_tmp = rtb_Sin * localDW->Delay6_DSTATE;\r\n\r\n  /* Sum: '<S16>/Add1' incorporates:\r\n   *  Concatenate: '<S17>/Matrix Concatenate'\r\n   *  Constant: '<S17>/Constant4'\r\n   *  Constant: '<S17>/Constant5'\r\n   *  Gain: '<S17>/Gain1'\r\n   *  IdentityMatrix: '<S16>/IdentityMatrix'\r\n   *  Math: '<S20>/Transpose'\r\n   *  Product: '<S16>/Matrix Multiply'\r\n   *  Product: '<S17>/Product'\r\n   *  Product: '<S17>/Product1'\r\n   */\r\n  rtb_Add_i[12] = rtb_Add_l_tmp * rtb_SignPreIntegrator_bb * 0.0001F;\r\n  rtb_Add_i[13] = rtb_Add_l_tmp * rtb_Cos * 0.0001F;\r\n  rtb_Add_i[14] = 0.0F;\r\n  rtb_Add_i[15] = 0.0F;\r\n  mw_arm_add_f32(&localDW->IdentityMatrix[0], &rtb_Add_i[0], &rtb_Transpose[0],\r\n                 16U);\r\n  for (i_0 = 0; i_0 < 4; i_0++) {\r\n    /* Product: '<S20>/Matrix Multiply' incorporates:\r\n     *  Delay: '<S6>/Delay1'\r\n     *  Math: '<S20>/Transpose'\r\n     */\r\n    for (i = 0; i < 4; i++) {\r\n      rtb_Transpose_tmp_tmp = i << 2;\r\n      rtb_Transpose_tmp = i_0 + rtb_Transpose_tmp_tmp;\r\n      rtb_Transpose_0[rtb_Transpose_tmp] = 0.0F;\r\n      rtb_Transpose_0[rtb_Transpose_tmp] += localDW->\r\n        Delay1_DSTATE[rtb_Transpose_tmp_tmp] * rtb_Transpose[i_0];\r\n      rtb_Transpose_0[rtb_Transpose_tmp] += localDW->\r\n        Delay1_DSTATE[rtb_Transpose_tmp_tmp + 1] * rtb_Transpose[i_0 + 4];\r\n      rtb_Transpose_0[rtb_Transpose_tmp] += localDW->\r\n        Delay1_DSTATE[rtb_Transpose_tmp_tmp + 2] * rtb_Transpose[i_0 + 8];\r\n      rtb_Transpose_0[rtb_Transpose_tmp] += localDW->\r\n        Delay1_DSTATE[rtb_Transpose_tmp_tmp + 3] * rtb_Transpose[i_0 + 12];\r\n    }\r\n\r\n    /* End of Product: '<S20>/Matrix Multiply' */\r\n    for (i = 0; i < 4; i++) {\r\n      /* Sum: '<S20>/Add' incorporates:\r\n       *  Math: '<S20>/Transpose'\r\n       *  Product: '<S20>/Matrix Multiply1'\r\n       */\r\n      rtb_Transpose_tmp_tmp = (i << 2) + i_0;\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] = 0.0F;\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] += rtb_Transpose_0[i_0] * rtb_Transpose[i];\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] += rtb_Transpose_0[i_0 + 4] *\r\n        rtb_Transpose[i + 4];\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] += rtb_Transpose_0[i_0 + 8] *\r\n        rtb_Transpose[i + 8];\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] += rtb_Transpose_0[i_0 + 12] *\r\n        rtb_Transpose[i + 12];\r\n    }\r\n  }\r\n\r\n  /* Sum: '<S20>/Add' incorporates:\r\n   *  Constant: '<S6>/Q'\r\n   *  Product: '<S20>/Matrix Multiply1'\r\n   */\r\n  mw_arm_add_f32(&rtb_Add_i[0], &rtConstP.Q_Value[0], &rtb_Transpose[0], 16U);\r\n\r\n  /* Product: '<S18>/Matrix Multiply' incorporates:\r\n   *  Math: '<S18>/Transpose'\r\n   *  Sum: '<S20>/Add'\r\n   */\r\n  for (i_0 = 0; i_0 < 2; i_0++) {\r\n    for (i = 0; i < 4; i++) {\r\n      rtb_Transpose_tmp_tmp = i_0 << 2;\r\n      rtb_Transpose_tmp = i + rtb_Transpose_tmp_tmp;\r\n      rtb_Divide[rtb_Transpose_tmp] = 0.0F;\r\n      rtb_Divide[rtb_Transpose_tmp] += localC->Transpose[rtb_Transpose_tmp_tmp] *\r\n        rtb_Transpose[i];\r\n      rtb_Divide[rtb_Transpose_tmp] += localC->Transpose[rtb_Transpose_tmp_tmp +\r\n        1] * rtb_Transpose[i + 4];\r\n      rtb_Divide[rtb_Transpose_tmp] += localC->Transpose[rtb_Transpose_tmp_tmp +\r\n        2] * rtb_Transpose[i + 8];\r\n      rtb_Divide[rtb_Transpose_tmp] += localC->Transpose[rtb_Transpose_tmp_tmp +\r\n        3] * rtb_Transpose[i + 12];\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < 8; i++) {\r\n    rtb_Add_i[i] = rtb_Divide[i];\r\n  }\r\n\r\n  /* End of Product: '<S18>/Matrix Multiply' */\r\n  for (i_0 = 0; i_0 < 2; i_0++) {\r\n    for (i = 0; i < 2; i++) {\r\n      /* Sum: '<S18>/Add' incorporates:\r\n       *  Constant: '<S6>/H'\r\n       *  Product: '<S18>/Matrix Multiply1'\r\n       */\r\n      rtb_Transpose_tmp_tmp = (i_0 << 1) + i;\r\n      rtb_VectorConcatenate4[rtb_Transpose_tmp_tmp] = 0.0F;\r\n\r\n      /* Product: '<S18>/Matrix Multiply1' */\r\n      rtb_Transpose_tmp = i_0 << 2;\r\n\r\n      /* Sum: '<S18>/Add' incorporates:\r\n       *  Constant: '<S6>/H'\r\n       *  Product: '<S18>/Matrix Multiply1'\r\n       */\r\n      rtb_VectorConcatenate4[rtb_Transpose_tmp_tmp] +=\r\n        rtb_Divide[rtb_Transpose_tmp] * rtConstP.H_Value[i];\r\n      rtb_VectorConcatenate4[rtb_Transpose_tmp_tmp] +=\r\n        rtb_Divide[rtb_Transpose_tmp + 1] * rtConstP.H_Value[i + 2];\r\n      rtb_VectorConcatenate4[rtb_Transpose_tmp_tmp] +=\r\n        rtb_Divide[rtb_Transpose_tmp + 2] * rtConstP.H_Value[i + 4];\r\n      rtb_VectorConcatenate4[rtb_Transpose_tmp_tmp] +=\r\n        rtb_Divide[rtb_Transpose_tmp + 3] * rtConstP.H_Value[i + 6];\r\n    }\r\n  }\r\n\r\n  /* Sum: '<S18>/Add' incorporates:\r\n   *  Constant: '<S6>/R'\r\n   *  Product: '<S18>/Matrix Multiply1'\r\n   */\r\n  mw_arm_add_f32(&rtb_VectorConcatenate4[0], &rtConstP.R_Value[0],\r\n                 &rtb_VectorConcatenate1[0], 4U);\r\n\r\n  /* Product: '<S18>/Divide' incorporates:\r\n   *  Sum: '<S18>/Add'\r\n   */\r\n  rt_mrdivide_U1f4x2_U2f2x2_Yf4x2(&rtb_Add_i[0], rtb_VectorConcatenate1,\r\n    rtb_Divide);\r\n\r\n  /* Sum: '<S23>/Add' incorporates:\r\n   *  Delay: '<S6>/Delay2'\r\n   *  Delay: '<S6>/Delay4'\r\n   *  Delay: '<S6>/Delay5'\r\n   *  Gain: '<S23>/Gain2'\r\n   *  Gain: '<S23>/Gain4'\r\n   *  Product: '<S23>/Product1'\r\n   *  Trigonometry: '<S23>/Cos1'\r\n   */\r\n  rtb_MatrixMultiply_d[0] = rtb_Sin * localDW->Delay4_DSTATE * sinf\r\n    (localDW->Delay5_DSTATE) + DiscreteTimeIntegrator1_n_0 *\r\n    localDW->Delay2_DSTATE;\r\n\r\n  /* Sum: '<S23>/Add1' incorporates:\r\n   *  Delay: '<S6>/Delay3'\r\n   *  Delay: '<S6>/Delay4'\r\n   *  Delay: '<S6>/Delay5'\r\n   *  Gain: '<S23>/Gain1'\r\n   *  Gain: '<S23>/Gain5'\r\n   *  Product: '<S23>/Product2'\r\n   *  Trigonometry: '<S23>/Cos'\r\n   */\r\n  rtb_MatrixMultiply_d[1] = rtb_Add_l_tmp_0 * localDW->Delay4_DSTATE * cosf\r\n    (localDW->Delay5_DSTATE) + DiscreteTimeIntegrator1_n_0 *\r\n    localDW->Delay3_DSTATE;\r\n\r\n  /* SignalConversion generated from: '<S23>/Vector Concatenate4' incorporates:\r\n   *  Constant: '<S23>/Constant'\r\n   */\r\n  rtb_MatrixMultiply_d[2] = 0.0F;\r\n\r\n  /* SignalConversion generated from: '<S23>/Vector Concatenate4' incorporates:\r\n   *  Delay: '<S6>/Delay4'\r\n   */\r\n  rtb_MatrixMultiply_d[3] = localDW->Delay4_DSTATE;\r\n  for (i_0 = 0; i_0 < 4; i_0++) {\r\n    /* Sum: '<S22>/Add2' incorporates:\r\n     *  Constant: '<S6>/B'\r\n     *  Product: '<S22>/Matrix Multiply1'\r\n     *  SignalConversion generated from: '<S6>/Vector Concatenate'\r\n     * */\r\n    rtb_VectorConcatenate4[i_0] = rtConstP.B_Value[i_0 + 4] * ubeta +\r\n      rtConstP.B_Value[i_0] * ualpha;\r\n  }\r\n\r\n  /* Sum: '<S22>/Add2' incorporates:\r\n   *  Product: '<S21>/Matrix Multiply'\r\n   *  Product: '<S22>/Matrix Multiply1'\r\n   */\r\n  mw_arm_add_f32(&rtb_MatrixMultiply_d[0], &rtb_VectorConcatenate4[0],\r\n                 &rtb_VectorConcatenate1[0], 4U);\r\n\r\n  /* Sum: '<S22>/Add1' incorporates:\r\n   *  Delay: '<S6>/Delay'\r\n   *  Gain: '<S22>/Gain'\r\n   *  Sum: '<S22>/Add2'\r\n   */\r\n  rtb_VectorConcatenate1[0] *= 0.0001F;\r\n  rtb_VectorConcatenate1[1] *= 0.0001F;\r\n  rtb_VectorConcatenate1[2] *= 0.0001F;\r\n  rtb_VectorConcatenate1[3] *= 0.0001F;\r\n  mw_arm_add_f32(&localDW->Delay_DSTATE[0], &rtb_VectorConcatenate1[0],\r\n                 &rtb_Add1[0], 4U);\r\n\r\n  /* SignalConversion generated from: '<S6>/Vector Concatenate2' */\r\n  rtb_VectorConcatenate[0] = ialpha;\r\n\r\n  /* SignalConversion generated from: '<S6>/Vector Concatenate2' */\r\n  rtb_VectorConcatenate[1] = ibeta;\r\n\r\n  /* Outputs for Atomic SubSystem: '<S6>/X_hat' */\r\n  for (i_0 = 0; i_0 < 2; i_0++) {\r\n    /* Sum: '<S21>/Add1' incorporates:\r\n     *  Constant: '<S6>/H'\r\n     *  Product: '<S21>/Matrix Multiply1'\r\n     *  Sum: '<S22>/Add1'\r\n     */\r\n    tmp[i_0] = ((rtConstP.H_Value[i_0 + 2] * rtb_Add1[1] + rtConstP.H_Value[i_0]\r\n                 * rtb_Add1[0]) + rtConstP.H_Value[i_0 + 4] * rtb_Add1[2]) +\r\n      rtConstP.H_Value[i_0 + 6] * rtb_Add1[3];\r\n  }\r\n\r\n  /* Sum: '<S21>/Add1' incorporates:\r\n   *  Concatenate: '<S6>/Vector Concatenate2'\r\n   *  Product: '<S21>/Matrix Multiply1'\r\n   */\r\n  mw_arm_sub_f32(&rtb_VectorConcatenate[0], &tmp[0], &tmp_0[0], 2U);\r\n  for (i_0 = 0; i_0 < 4; i_0++) {\r\n    /* Sum: '<S21>/Add' incorporates:\r\n     *  Product: '<S18>/Divide'\r\n     *  Product: '<S21>/Matrix Multiply'\r\n     *  Sum: '<S21>/Add1'\r\n     */\r\n    rtb_VectorConcatenate4[i_0] = rtb_Divide[i_0 + 4] * tmp_0[1] +\r\n      rtb_Divide[i_0] * tmp_0[0];\r\n  }\r\n\r\n  /* Sum: '<S21>/Add' incorporates:\r\n   *  Product: '<S21>/Matrix Multiply'\r\n   *  Sum: '<S22>/Add1'\r\n   */\r\n  mw_arm_add_f32(&rtb_Add1[0], &rtb_VectorConcatenate4[0], &rtb_Add_n[0], 4U);\r\n\r\n  /* End of Outputs for SubSystem: '<S6>/X_hat' */\r\n\r\n  /* Update for Delay: '<S6>/Delay7' */\r\n  localDW->Delay7_DSTATE = rtb_Add_n[3];\r\n\r\n  /* Update for Delay: '<S6>/Delay6' */\r\n  localDW->Delay6_DSTATE = rtb_Add_n[2];\r\n  for (i_0 = 0; i_0 < 4; i_0++) {\r\n    for (i = 0; i < 4; i++) {\r\n      /* Sum: '<S19>/Add' incorporates:\r\n       *  Constant: '<S6>/H'\r\n       *  Product: '<S19>/Matrix Multiply1'\r\n       */\r\n      rtb_Transpose_tmp_tmp = (i_0 << 2) + i;\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] = 0.0F;\r\n\r\n      /* Product: '<S19>/Matrix Multiply1' incorporates:\r\n       *  Constant: '<S6>/H'\r\n       */\r\n      rtb_Transpose_tmp = i_0 << 1;\r\n\r\n      /* Sum: '<S19>/Add' incorporates:\r\n       *  Constant: '<S6>/H'\r\n       *  Product: '<S18>/Divide'\r\n       *  Product: '<S19>/Matrix Multiply1'\r\n       */\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] += rtConstP.H_Value[rtb_Transpose_tmp] *\r\n        rtb_Divide[i];\r\n      rtb_Add_i[rtb_Transpose_tmp_tmp] += rtConstP.H_Value[rtb_Transpose_tmp + 1]\r\n        * rtb_Divide[i + 4];\r\n    }\r\n  }\r\n\r\n  /* Sum: '<S19>/Add' incorporates:\r\n   *  IdentityMatrix: '<S19>/IdentityMatrix'\r\n   *  Product: '<S19>/Matrix Multiply1'\r\n   */\r\n  mw_arm_sub_f32(&localDW->IdentityMatrix_k[0], &rtb_Add_i[0], &rtb_Transpose_0\r\n                 [0], 16U);\r\n\r\n  /* Update for Delay: '<S6>/Delay2' */\r\n  localDW->Delay2_DSTATE = rtb_Add_n[0];\r\n\r\n  /* Update for Delay: '<S6>/Delay4' */\r\n  localDW->Delay4_DSTATE = rtb_Add_n[2];\r\n\r\n  /* Update for Delay: '<S6>/Delay5' */\r\n  localDW->Delay5_DSTATE = rtb_Add_n[3];\r\n\r\n  /* Update for Delay: '<S6>/Delay3' */\r\n  localDW->Delay3_DSTATE = rtb_Add_n[1];\r\n  for (i = 0; i < 4; i++) {\r\n    /* Update for Delay: '<S6>/Delay1' incorporates:\r\n     *  Product: '<S19>/Matrix Multiply'\r\n     *  Sum: '<S19>/Add'\r\n     *  Sum: '<S20>/Add'\r\n     */\r\n    for (i_0 = 0; i_0 < 4; i_0++) {\r\n      /* Product: '<S19>/Matrix Multiply' incorporates:\r\n       *  Sum: '<S19>/Add'\r\n       */\r\n      rtb_Transpose_tmp_tmp = i_0 << 2;\r\n      rtb_Transpose_tmp = i + rtb_Transpose_tmp_tmp;\r\n      localDW->Delay1_DSTATE[rtb_Transpose_tmp] = 0.0F;\r\n      localDW->Delay1_DSTATE[rtb_Transpose_tmp] +=\r\n        rtb_Transpose[rtb_Transpose_tmp_tmp] * rtb_Transpose_0[i];\r\n      localDW->Delay1_DSTATE[rtb_Transpose_tmp] +=\r\n        rtb_Transpose[rtb_Transpose_tmp_tmp + 1] * rtb_Transpose_0[i + 4];\r\n      localDW->Delay1_DSTATE[rtb_Transpose_tmp] +=\r\n        rtb_Transpose[rtb_Transpose_tmp_tmp + 2] * rtb_Transpose_0[i + 8];\r\n      localDW->Delay1_DSTATE[rtb_Transpose_tmp] +=\r\n        rtb_Transpose[rtb_Transpose_tmp_tmp + 3] * rtb_Transpose_0[i + 12];\r\n    }\r\n\r\n    /* End of Update for Delay: '<S6>/Delay1' */\r\n\r\n    /* Update for Delay: '<S6>/Delay' incorporates:\r\n     *  Sum: '<S21>/Add'\r\n     */\r\n    localDW->Delay_DSTATE[i] = rtb_Add_n[i];\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S2>/EKF' */\r\n\r\n  /* Gain: '<S2>/Gain1' incorporates:\r\n   *  Gain: '<S2>/Gain2'\r\n   */\r\n  *rty_EKFWm = 1.0F / motor.Pn * rtb_Add_n[2] * 9.54929638F;\r\n\r\n  /* Math: '<S2>/Mod' incorporates:\r\n   *  Constant: '<S2>/Constant1'\r\n   */\r\n  EKFTheta = rt_modf(rtb_Add_n[3], 6.28318548F);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S2>/SVPWM1' */\r\n  SVPWM1(ualpha, ubeta, rtu_VDC, rty_Tcmp1);\r\n\r\n  /* End of Outputs for SubSystem: '<S2>/SVPWM1' */\r\n\r\n  /* SignalConversion generated from: '<S2>/Tcmp2' */\r\n  *rty_Tcmp2 = rty_Tcmp1[1];\r\n\r\n  /* SignalConversion generated from: '<S2>/Tcmp3' */\r\n  *rty_Tcmp3 = rty_Tcmp1[2];\r\n\r\n  /* DeadZone: '<S58>/DeadZone' */\r\n  if (DiscreteTimeIntegrator1_n > 12.4707661F) {\r\n    DiscreteTimeIntegrator1_n -= 12.4707661F;\r\n  } else if (DiscreteTimeIntegrator1_n >= -12.4707661F) {\r\n    DiscreteTimeIntegrator1_n = 0.0F;\r\n  } else {\r\n    DiscreteTimeIntegrator1_n -= -12.4707661F;\r\n  }\r\n\r\n  /* End of DeadZone: '<S58>/DeadZone' */\r\n\r\n  /* Product: '<S62>/IProd Out' incorporates:\r\n   *  Constant: '<S15>/Constant4'\r\n   */\r\n  rtb_IProdOut_p = (int16_T)floorf(rtb_Sum1 * curr_kpki.curr_d_ki);\r\n\r\n  /* DeadZone: '<S108>/DeadZone' */\r\n  if (DiscreteTimeIntegrator > 12.4707661F) {\r\n    DiscreteTimeIntegrator -= 12.4707661F;\r\n  } else if (DiscreteTimeIntegrator >= -12.4707661F) {\r\n    DiscreteTimeIntegrator = 0.0F;\r\n  } else {\r\n    DiscreteTimeIntegrator -= -12.4707661F;\r\n  }\r\n\r\n  /* End of DeadZone: '<S108>/DeadZone' */\r\n\r\n  /* Product: '<S112>/IProd Out' incorporates:\r\n   *  Constant: '<S15>/Constant2'\r\n   */\r\n  rtb_IProdOut *= curr_kpki.curr_d_ki;\r\n\r\n  /* Update for SwitchCase: '<S2>/Switch Case1' */\r\n  switch (localDW->SwitchCase1_ActiveSubsystem) {\r\n   case 0:\r\n   case 1:\r\n   case 4:\r\n    break;\r\n\r\n   case 2:\r\n    /* Update for IfAction SubSystem: '<S2>/If Action Subsystem2' incorporates:\r\n     *  ActionPort: '<S9>/Action Port'\r\n     */\r\n    localDW->IfActionSubsystem2_PREV_T = Curr_loop_PREV_T_tmp;\r\n    localDW->IfActionSubsystem2_RESET_ELAPS_ = false;\r\n\r\n    /* End of Update for SubSystem: '<S2>/If Action Subsystem2' */\r\n    break;\r\n\r\n   case 3:\r\n    /* Update for IfAction SubSystem: '<S2>/If Action Subsystem4' incorporates:\r\n     *  ActionPort: '<S11>/Action Port'\r\n     */\r\n    localDW->IfActionSubsystem4_PREV_T = Curr_loop_PREV_T_tmp;\r\n    localDW->IfActionSubsystem4_RESET_ELAPS_ = false;\r\n\r\n    /* End of Update for SubSystem: '<S2>/If Action Subsystem4' */\r\n    break;\r\n  }\r\n\r\n  /* Update for DiscreteIntegrator: '<S65>/Integrator' */\r\n  localDW->Integrator_SYSTEM_ENABLE = 0U;\r\n  localDW->Integrator_DSTATE_f = Integrator_g;\r\n\r\n  /* Signum: '<S56>/SignPreSat' */\r\n  if (DiscreteTimeIntegrator1_n < 0.0F) {\r\n    DiscreteTimeIntegrator1_n_0 = -1.0F;\r\n  } else if (DiscreteTimeIntegrator1_n > 0.0F) {\r\n    DiscreteTimeIntegrator1_n_0 = 1.0F;\r\n  } else {\r\n    DiscreteTimeIntegrator1_n_0 = DiscreteTimeIntegrator1_n;\r\n  }\r\n\r\n  /* End of Signum: '<S56>/SignPreSat' */\r\n\r\n  /* Signum: '<S56>/SignPreIntegrator' */\r\n  if (rtb_IProdOut_p < 0) {\r\n    Integrator_g = -1;\r\n  } else {\r\n    Integrator_g = (int16_T)(rtb_IProdOut_p > 0);\r\n  }\r\n\r\n  /* End of Signum: '<S56>/SignPreIntegrator' */\r\n\r\n  /* Switch: '<S56>/Switch' incorporates:\r\n   *  DataTypeConversion: '<S56>/DataTypeConv1'\r\n   *  DataTypeConversion: '<S56>/DataTypeConv2'\r\n   *  Logic: '<S56>/AND3'\r\n   *  RelationalOperator: '<S56>/Equal1'\r\n   *  RelationalOperator: '<S56>/NotEqual'\r\n   */\r\n  if ((0.0F != DiscreteTimeIntegrator1_n) && ((int8_T)\r\n       DiscreteTimeIntegrator1_n_0 == Integrator_g)) {\r\n    /* Update for DiscreteIntegrator: '<S65>/Integrator' incorporates:\r\n     *  Constant: '<S56>/Constant1'\r\n     */\r\n    localDW->Integrator_PREV_U_l = 0;\r\n  } else {\r\n    /* Update for DiscreteIntegrator: '<S65>/Integrator' */\r\n    localDW->Integrator_PREV_U_l = rtb_IProdOut_p;\r\n  }\r\n\r\n  /* End of Switch: '<S56>/Switch' */\r\n\r\n  /* Update for DiscreteIntegrator: '<S115>/Integrator' */\r\n  localDW->Integrator_SYSTEM_ENABLE_e = 0U;\r\n  localDW->Integrator_DSTATE = Integrator;\r\n\r\n  /* Signum: '<S106>/SignPreSat' */\r\n  if (DiscreteTimeIntegrator < 0.0F) {\r\n    rtb_SignPreIntegrator_bb = -1.0F;\r\n  } else if (DiscreteTimeIntegrator > 0.0F) {\r\n    rtb_SignPreIntegrator_bb = 1.0F;\r\n  } else {\r\n    rtb_SignPreIntegrator_bb = DiscreteTimeIntegrator;\r\n  }\r\n\r\n  /* End of Signum: '<S106>/SignPreSat' */\r\n\r\n  /* Signum: '<S106>/SignPreIntegrator' */\r\n  if (rtb_IProdOut < 0.0F) {\r\n    DiscreteTimeIntegrator1_n = -1.0F;\r\n  } else if (rtb_IProdOut > 0.0F) {\r\n    DiscreteTimeIntegrator1_n = 1.0F;\r\n  } else {\r\n    DiscreteTimeIntegrator1_n = rtb_IProdOut;\r\n  }\r\n\r\n  /* End of Signum: '<S106>/SignPreIntegrator' */\r\n\r\n  /* Switch: '<S106>/Switch' incorporates:\r\n   *  DataTypeConversion: '<S106>/DataTypeConv1'\r\n   *  DataTypeConversion: '<S106>/DataTypeConv2'\r\n   *  Logic: '<S106>/AND3'\r\n   *  RelationalOperator: '<S106>/Equal1'\r\n   *  RelationalOperator: '<S106>/NotEqual'\r\n   */\r\n  if ((0.0F != DiscreteTimeIntegrator) && ((int8_T)rtb_SignPreIntegrator_bb ==\r\n       (int8_T)DiscreteTimeIntegrator1_n)) {\r\n    /* Update for DiscreteIntegrator: '<S115>/Integrator' incorporates:\r\n     *  Constant: '<S106>/Constant1'\r\n     */\r\n    localDW->Integrator_PREV_U = 0.0F;\r\n  } else {\r\n    /* Update for DiscreteIntegrator: '<S115>/Integrator' */\r\n    localDW->Integrator_PREV_U = rtb_IProdOut;\r\n  }\r\n\r\n  /* End of Switch: '<S106>/Switch' */\r\n}\r\n\r\n/* Model step function */\r\nvoid FOC_Model_step(void)\r\n{\r\n  real32_T PWM_HalfPeriod[3];\r\n\r\n  /* RateTransition: '<S1>/Rate Transition3' */\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    /* RateTransition: '<S1>/Rate Transition3' */\r\n    rtDW.RateTransition3 = rtDW.RateTransition3_Buffer0;\r\n  }\r\n\r\n  /* End of RateTransition: '<S1>/Rate Transition3' */\r\n\r\n  /* S-Function (fcgen): '<S1>/Function-Call Generator1' incorporates:\r\n   *  SubSystem: '<S1>/Curr_loop'\r\n   */\r\n  /* Inport: '<Root>/ia' incorporates:\r\n   *  Inport: '<Root>/MotorOnOff'\r\n   *  Inport: '<Root>/VDC'\r\n   *  Inport: '<Root>/ib'\r\n   *  Inport: '<Root>/ic'\r\n   *  Outport: '<Root>/Tcmp2'\r\n   *  Outport: '<Root>/Tcmp3'\r\n   */\r\n  Curr_loop(rtM, rtU.ia, rtU.ib, rtU.ic, rtU.MotorOnOff, rtDW.RateTransition3,\r\n            rtU.VDC, PWM_HalfPeriod, &rtY.Tcmp2, &rtY.Tcmp3, &EKFWm,\r\n            &rtDW.RestsSingal, &rtConstB.Curr_loop_d, &rtDW.Curr_loop_d);\r\n\r\n  /* End of Outputs for S-Function (fcgen): '<S1>/Function-Call Generator1' */\r\n\r\n  /* Outport: '<Root>/Tcmp1' */\r\n  rtY.Tcmp1 = PWM_HalfPeriod[0];\r\n\r\n  /* RateTransition: '<S1>/Rate Transition' */\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    real32_T Integrator;\r\n    real32_T rtb_IntegralGain;\r\n    real32_T rtb_IntegralGain_0;\r\n    real32_T rtb_SignPreIntegrator;\r\n    real32_T rtb_Sum;\r\n    uint32_T Speed_loop_ELAPS_T;\r\n\r\n    /* S-Function (fcgen): '<S1>/Function-Call Generator' incorporates:\r\n     *  SubSystem: '<S1>/Speed_loop'\r\n     */\r\n    if (rtDW.Speed_loop_RESET_ELAPS_T) {\r\n      Speed_loop_ELAPS_T = 0U;\r\n    } else {\r\n      Speed_loop_ELAPS_T = rtM->Timing.clockTick1 - rtDW.Speed_loop_PREV_T;\r\n    }\r\n\r\n    rtDW.Speed_loop_PREV_T = rtM->Timing.clockTick1;\r\n    rtDW.Speed_loop_RESET_ELAPS_T = false;\r\n\r\n    /* Sum: '<S3>/Sum2' incorporates:\r\n     *  Inport: '<Root>/Speed_ref'\r\n     */\r\n    rtb_IntegralGain = rtU.Speed_ref - EKFWm;\r\n\r\n    /* DiscreteIntegrator: '<S166>/Integrator' incorporates:\r\n     *  RateTransition: '<S1>/Rate Transition2'\r\n     */\r\n    if (rtDW.Integrator_SYSTEM_ENABLE != 0) {\r\n      /* DiscreteIntegrator: '<S166>/Integrator' */\r\n      Integrator = rtDW.Integrator_DSTATE;\r\n    } else if ((rtDW.RestsSingal > 0.0) && (rtDW.Integrator_PrevResetState <= 0))\r\n    {\r\n      rtDW.Integrator_DSTATE = 0.0F;\r\n\r\n      /* DiscreteIntegrator: '<S166>/Integrator' */\r\n      Integrator = rtDW.Integrator_DSTATE;\r\n    } else {\r\n      /* DiscreteIntegrator: '<S166>/Integrator' */\r\n      Integrator = 0.001F * (real32_T)Speed_loop_ELAPS_T\r\n        * rtDW.Integrator_PREV_U + rtDW.Integrator_DSTATE;\r\n    }\r\n\r\n    /* End of DiscreteIntegrator: '<S166>/Integrator' */\r\n\r\n    /* Sum: '<S175>/Sum' incorporates:\r\n     *  Gain: '<S171>/Proportional Gain'\r\n     */\r\n    rtb_Sum = spd_kpki.spd_kp * rtb_IntegralGain + Integrator;\r\n\r\n    /* DeadZone: '<S159>/DeadZone' */\r\n    if (rtb_Sum > 3.0F) {\r\n      rtb_SignPreIntegrator = rtb_Sum - 3.0F;\r\n    } else if (rtb_Sum >= -3.0F) {\r\n      rtb_SignPreIntegrator = 0.0F;\r\n    } else {\r\n      rtb_SignPreIntegrator = rtb_Sum - -3.0F;\r\n    }\r\n\r\n    /* End of DeadZone: '<S159>/DeadZone' */\r\n\r\n    /* Gain: '<S163>/Integral Gain' */\r\n    rtb_IntegralGain *= spd_kpki.spd_ki;\r\n\r\n    /* Update for DiscreteIntegrator: '<S166>/Integrator' incorporates:\r\n     *  RateTransition: '<S1>/Rate Transition2'\r\n     */\r\n    rtDW.Integrator_SYSTEM_ENABLE = 0U;\r\n    rtDW.Integrator_DSTATE = Integrator;\r\n    if (rtDW.RestsSingal > 0.0) {\r\n      rtDW.Integrator_PrevResetState = 1;\r\n    } else if (rtDW.RestsSingal < 0.0) {\r\n      rtDW.Integrator_PrevResetState = -1;\r\n    } else if (rtDW.RestsSingal == 0.0) {\r\n      rtDW.Integrator_PrevResetState = 0;\r\n    } else {\r\n      rtDW.Integrator_PrevResetState = 2;\r\n    }\r\n\r\n    /* Signum: '<S157>/SignPreSat' */\r\n    if (rtb_SignPreIntegrator < 0.0F) {\r\n      Integrator = -1.0F;\r\n    } else if (rtb_SignPreIntegrator > 0.0F) {\r\n      Integrator = 1.0F;\r\n    } else {\r\n      Integrator = rtb_SignPreIntegrator;\r\n    }\r\n\r\n    /* End of Signum: '<S157>/SignPreSat' */\r\n\r\n    /* Signum: '<S157>/SignPreIntegrator' */\r\n    if (rtb_IntegralGain < 0.0F) {\r\n      rtb_IntegralGain_0 = -1.0F;\r\n    } else if (rtb_IntegralGain > 0.0F) {\r\n      rtb_IntegralGain_0 = 1.0F;\r\n    } else {\r\n      rtb_IntegralGain_0 = rtb_IntegralGain;\r\n    }\r\n\r\n    /* End of Signum: '<S157>/SignPreIntegrator' */\r\n\r\n    /* Switch: '<S157>/Switch' incorporates:\r\n     *  DataTypeConversion: '<S157>/DataTypeConv1'\r\n     *  DataTypeConversion: '<S157>/DataTypeConv2'\r\n     *  Gain: '<S157>/ZeroGain'\r\n     *  Logic: '<S157>/AND3'\r\n     *  RelationalOperator: '<S157>/Equal1'\r\n     *  RelationalOperator: '<S157>/NotEqual'\r\n     */\r\n    if ((0.0F != rtb_SignPreIntegrator) && ((int8_T)Integrator == (int8_T)\r\n         rtb_IntegralGain_0)) {\r\n      /* Update for DiscreteIntegrator: '<S166>/Integrator' incorporates:\r\n       *  Constant: '<S157>/Constant1'\r\n       */\r\n      rtDW.Integrator_PREV_U = 0.0F;\r\n    } else {\r\n      /* Update for DiscreteIntegrator: '<S166>/Integrator' */\r\n      rtDW.Integrator_PREV_U = rtb_IntegralGain;\r\n    }\r\n\r\n    /* End of Switch: '<S157>/Switch' */\r\n\r\n    /* Saturate: '<S173>/Saturation' */\r\n    if (rtb_Sum > 3.0F) {\r\n      /* Update for RateTransition: '<S1>/Rate Transition3' */\r\n      rtDW.RateTransition3_Buffer0 = 3.0F;\r\n    } else if (rtb_Sum < -3.0F) {\r\n      /* Update for RateTransition: '<S1>/Rate Transition3' */\r\n      rtDW.RateTransition3_Buffer0 = -3.0F;\r\n    } else {\r\n      /* Update for RateTransition: '<S1>/Rate Transition3' */\r\n      rtDW.RateTransition3_Buffer0 = rtb_Sum;\r\n    }\r\n\r\n    /* End of Saturate: '<S173>/Saturation' */\r\n    /* End of Outputs for S-Function (fcgen): '<S1>/Function-Call Generator' */\r\n  }\r\n\r\n  /* End of RateTransition: '<S1>/Rate Transition' */\r\n\r\n  /* Update absolute time for base rate */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The resolution of this integer timer is 0.0001, which is the step size\r\n   * of the task. Size of \"clockTick0\" ensures timer will not overflow during the\r\n   * application lifespan selected.\r\n   */\r\n  rtM->Timing.clockTick0++;\r\n  if (rtM->Timing.TaskCounters.TID[1] == 0) {\r\n    /* Update absolute timer for sample time: [0.001s, 0.0s] */\r\n    /* The \"clockTick1\" counts the number of times the code of this task has\r\n     * been executed. The resolution of this integer timer is 0.001, which is the step size\r\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n     * application lifespan selected.\r\n     */\r\n    rtM->Timing.clockTick1++;\r\n  }\r\n\r\n  rate_scheduler();\r\n}\r\n\r\n/* Model initialize function */\r\nvoid FOC_Model_initialize(void)\r\n{\r\n  /* SystemInitialize for S-Function (fcgen): '<S1>/Function-Call Generator1' incorporates:\r\n   *  SubSystem: '<S1>/Curr_loop'\r\n   */\r\n  Curr_loop_Init(&rtDW.RestsSingal, &rtDW.Curr_loop_d);\r\n\r\n  /* End of SystemInitialize for S-Function (fcgen): '<S1>/Function-Call Generator1' */\r\n\r\n  /* SystemInitialize for S-Function (fcgen): '<S1>/Function-Call Generator' incorporates:\r\n   *  SubSystem: '<S1>/Speed_loop'\r\n   */\r\n  /* InitializeConditions for DiscreteIntegrator: '<S166>/Integrator' */\r\n  rtDW.Integrator_PrevResetState = 2;\r\n\r\n  /* End of SystemInitialize for S-Function (fcgen): '<S1>/Function-Call Generator' */\r\n\r\n  /* Enable for S-Function (fcgen): '<S1>/Function-Call Generator1' incorporates:\r\n   *  SubSystem: '<S1>/Curr_loop'\r\n   */\r\n  Curr_loop_Enable(&rtDW.Curr_loop_d);\r\n\r\n  /* End of Enable for S-Function (fcgen): '<S1>/Function-Call Generator1' */\r\n\r\n  /* Enable for S-Function (fcgen): '<S1>/Function-Call Generator' incorporates:\r\n   *  SubSystem: '<S1>/Speed_loop'\r\n   */\r\n  rtDW.Speed_loop_RESET_ELAPS_T = true;\r\n\r\n  /* Enable for DiscreteIntegrator: '<S166>/Integrator' */\r\n  rtDW.Integrator_SYSTEM_ENABLE = 1U;\r\n\r\n  /* End of Enable for S-Function (fcgen): '<S1>/Function-Call Generator' */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_Model.h","type":"header","group":"model","path":"C:\\Users\\Jay\\Desktop\\G4\\Simulink\\8.EKF\\BLDC\\BLDC_EKF_MODEL\\FOC_Model_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * File: FOC_Model.h\r\n *\r\n * Code generated for Simulink model 'FOC_Model'.\r\n *\r\n * Model version                  : 2.183\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sun Oct 22 20:56:15 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_FOC_Model_h_\r\n#define RTW_HEADER_FOC_Model_h_\r\n#include <float.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#ifndef FOC_Model_COMMON_INCLUDES_\r\n#define FOC_Model_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* FOC_Model_COMMON_INCLUDES_ */\r\n\r\n/* Model Code Variants */\r\n#include \"mw_cmsis.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM RT_MODEL;\r\n\r\n/* Block signals and states (default storage) for system '<S1>/Curr_loop' */\r\ntypedef struct {\r\n  real32_T IdentityMatrix[16];         /* '<S16>/IdentityMatrix' */\r\n  real32_T IdentityMatrix_k[16];       /* '<S19>/IdentityMatrix' */\r\n  real32_T Delay1_DSTATE[16];          /* '<S6>/Delay1' */\r\n  real32_T Delay_DSTATE[4];            /* '<S6>/Delay' */\r\n  real32_T Divide_DWORK4[4];           /* '<S18>/Divide' */\r\n  real32_T Merge;                      /* '<S2>/Merge' */\r\n  real32_T Merge1;                     /* '<S2>/Merge1' */\r\n  real32_T ZReset;                     /* '<S2>/Chart1' */\r\n  real32_T Integrator_DSTATE;          /* '<S115>/Integrator' */\r\n  real32_T DiscreteTimeIntegrator1_DSTATE;/* '<S11>/Discrete-Time Integrator1' */\r\n  real32_T UnitDelay_DSTATE;           /* '<S11>/Unit Delay' */\r\n  real32_T DiscreteTimeIntegrator_DSTATE;/* '<S9>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator1_DSTAT_j;/* '<S9>/Discrete-Time Integrator1' */\r\n  real32_T Delay7_DSTATE;              /* '<S6>/Delay7' */\r\n  real32_T Delay6_DSTATE;              /* '<S6>/Delay6' */\r\n  real32_T Delay2_DSTATE;              /* '<S6>/Delay2' */\r\n  real32_T Delay4_DSTATE;              /* '<S6>/Delay4' */\r\n  real32_T Delay5_DSTATE;              /* '<S6>/Delay5' */\r\n  real32_T Delay3_DSTATE;              /* '<S6>/Delay3' */\r\n  real32_T Integrator_PREV_U;          /* '<S115>/Integrator' */\r\n  real32_T DiscreteTimeIntegrator1_PREV_U;/* '<S11>/Discrete-Time Integrator1' */\r\n  real32_T DiscreteTimeIntegrator_PREV_U;/* '<S9>/Discrete-Time Integrator' */\r\n  real32_T DiscreteTimeIntegrator1_PREV__h;/* '<S9>/Discrete-Time Integrator1' */\r\n  real32_T cnt;                        /* '<S2>/Chart1' */\r\n  uint32_T Curr_loop_PREV_T;           /* '<S1>/Curr_loop' */\r\n  uint32_T IfActionSubsystem4_PREV_T;  /* '<S2>/If Action Subsystem4' */\r\n  uint32_T IfActionSubsystem2_PREV_T;  /* '<S2>/If Action Subsystem2' */\r\n  int16_T Integrator_DSTATE_f;         /* '<S65>/Integrator' */\r\n  int16_T Integrator_PREV_U_l;         /* '<S65>/Integrator' */\r\n  uint16_T temporalCounter_i1;         /* '<S2>/Chart1' */\r\n  int8_T SwitchCase1_ActiveSubsystem;  /* '<S2>/Switch Case1' */\r\n  int8_T DiscreteTimeIntegrator_PrevRese;/* '<S9>/Discrete-Time Integrator' */\r\n  int8_T DiscreteTimeIntegrator1_PrevRes;/* '<S9>/Discrete-Time Integrator1' */\r\n  uint8_T Integrator_SYSTEM_ENABLE;    /* '<S65>/Integrator' */\r\n  uint8_T Integrator_SYSTEM_ENABLE_e;  /* '<S115>/Integrator' */\r\n  uint8_T DiscreteTimeIntegrator1_SYSTEM_;/* '<S11>/Discrete-Time Integrator1' */\r\n  uint8_T DiscreteTimeIntegrator_SYSTEM_E;/* '<S9>/Discrete-Time Integrator' */\r\n  uint8_T DiscreteTimeIntegrator1_SYSTE_f;/* '<S9>/Discrete-Time Integrator1' */\r\n  uint8_T is_active_c7_FOC_Model;      /* '<S2>/Chart1' */\r\n  uint8_T is_c7_FOC_Model;             /* '<S2>/Chart1' */\r\n  boolean_T Curr_loop_RESET_ELAPS_T;   /* '<S1>/Curr_loop' */\r\n  boolean_T IfActionSubsystem4_RESET_ELAPS_;/* '<S2>/If Action Subsystem4' */\r\n  boolean_T IfActionSubsystem2_RESET_ELAPS_;/* '<S2>/If Action Subsystem2' */\r\n} DW_Curr_loop;\r\n\r\n/* Block signals and states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  DW_Curr_loop Curr_loop_d;            /* '<S1>/Curr_loop' */\r\n  real_T RestsSingal;                  /* '<S2>/Chart1' */\r\n  real32_T RateTransition3;            /* '<S1>/Rate Transition3' */\r\n  real32_T Integrator_DSTATE;          /* '<S166>/Integrator' */\r\n  real32_T RateTransition3_Buffer0;    /* '<S1>/Rate Transition3' */\r\n  real32_T Integrator_PREV_U;          /* '<S166>/Integrator' */\r\n  uint32_T Speed_loop_PREV_T;          /* '<S1>/Speed_loop' */\r\n  int8_T Integrator_PrevResetState;    /* '<S166>/Integrator' */\r\n  uint8_T Integrator_SYSTEM_ENABLE;    /* '<S166>/Integrator' */\r\n  boolean_T Speed_loop_RESET_ELAPS_T;  /* '<S1>/Speed_loop' */\r\n} DW;\r\n\r\n/* Invariant block signals for system '<S1>/Curr_loop' */\r\ntypedef struct {\r\n  const real32_T Transpose[8];         /* '<S18>/Transpose' */\r\n} ConstB_Curr_loop;\r\n\r\n/* Invariant block signals (default storage) */\r\ntypedef struct {\r\n  ConstB_Curr_loop Curr_loop_d;        /* '<S1>/Curr_loop' */\r\n} ConstB;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Computed Parameter: B_Value\r\n   * Referenced by: '<S6>/B'\r\n   */\r\n  real32_T B_Value[8];\r\n\r\n  /* Computed Parameter: H_Value\r\n   * Referenced by: '<S6>/H'\r\n   */\r\n  real32_T H_Value[8];\r\n\r\n  /* Computed Parameter: Q_Value\r\n   * Referenced by: '<S6>/Q'\r\n   */\r\n  real32_T Q_Value[16];\r\n\r\n  /* Computed Parameter: R_Value\r\n   * Referenced by: '<S6>/R'\r\n   */\r\n  real32_T R_Value[4];\r\n\r\n  /* Pooled Parameter (Expression: )\r\n   * Referenced by:\r\n   *   '<S16>/IdentityMatrix'\r\n   *   '<S19>/IdentityMatrix'\r\n   */\r\n  real32_T pooled4[16];\r\n} ConstP;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real32_T ia;                         /* '<Root>/ia' */\r\n  real32_T ib;                         /* '<Root>/ib' */\r\n  real32_T ic;                         /* '<Root>/ic' */\r\n  real32_T Speed_ref;                  /* '<Root>/Speed_ref' */\r\n  real32_T MotorOnOff;                 /* '<Root>/MotorOnOff' */\r\n  real32_T VDC;                        /* '<Root>/VDC' */\r\n} ExtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real32_T Tcmp1;                      /* '<Root>/Tcmp1' */\r\n  real32_T Tcmp2;                      /* '<Root>/Tcmp2' */\r\n  real32_T Tcmp3;                      /* '<Root>/Tcmp3' */\r\n} ExtY;\r\n\r\n/* Type definition for custom storage class: Struct */\r\ntypedef struct curr_kpki_tag {\r\n  real32_T curr_d_ki;                  /* Referenced by:\r\n                                        * '<S15>/Constant2'\r\n                                        * '<S15>/Constant4'\r\n                                        */\r\n  real32_T curr_d_kp;                  /* Referenced by:\r\n                                        * '<S15>/Constant1'\r\n                                        * '<S15>/Constant3'\r\n                                        */\r\n} curr_kpki_type;\r\n\r\ntypedef struct motor_tag {\r\n  real32_T L;                          /* Referenced by:\r\n                                        * '<S17>/Constant6'\r\n                                        * '<S17>/Constant7'\r\n                                        * '<S17>/Gain1'\r\n                                        * '<S17>/Gain2'\r\n                                        * '<S17>/Gain3'\r\n                                        * '<S17>/Gain4'\r\n                                        * '<S23>/Gain1'\r\n                                        * '<S23>/Gain2'\r\n                                        * '<S23>/Gain4'\r\n                                        * '<S23>/Gain5'\r\n                                        */\r\n  real32_T Pn;                         /* Referenced by:\r\n                                        * '<S2>/Gain2'\r\n                                        * '<S9>/Gain'\r\n                                        * '<S11>/Gain'\r\n                                        */\r\n  real32_T Rs;                         /* Referenced by:\r\n                                        * '<S17>/Constant6'\r\n                                        * '<S17>/Constant7'\r\n                                        * '<S23>/Gain4'\r\n                                        * '<S23>/Gain5'\r\n                                        */\r\n  real32_T flux;                       /* Referenced by:\r\n                                        * '<S17>/Gain1'\r\n                                        * '<S17>/Gain2'\r\n                                        * '<S17>/Gain3'\r\n                                        * '<S17>/Gain4'\r\n                                        * '<S23>/Gain1'\r\n                                        * '<S23>/Gain2'\r\n                                        */\r\n} motor_type;\r\n\r\ntypedef struct spd_kpki_tag {\r\n  real32_T spd_ki;                   /* Referenced by: '<S163>/Integral Gain' */\r\n  real32_T spd_kp;               /* Referenced by: '<S171>/Proportional Gain' */\r\n} spd_kpki_type;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTick1;\r\n    struct {\r\n      uint8_T TID[2];\r\n    } TaskCounters;\r\n  } Timing;\r\n};\r\n\r\n/* Block signals and states (default storage) */\r\nextern DW rtDW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU rtU;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY rtY;\r\nextern const ConstB rtConstB;          /* constant block i/o */\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP rtConstP;\r\n\r\n/*\r\n * Exported Global Signals\r\n *\r\n * Note: Exported global signals are block signals with an exported global\r\n * storage class designation.  Code generation will declare the memory for\r\n * these signals and export their symbols.\r\n *\r\n */\r\nextern real32_T EKFWm;                 /* '<S2>/Gain1' */\r\nextern real32_T EKFTheta;              /* '<S2>/Mod' */\r\nextern real32_T ualpha;                /* '<S12>/Add' */\r\nextern real32_T ubeta;                 /* '<S12>/Add1' */\r\nextern real32_T ialpha;                /* '<S5>/Add1' */\r\nextern real32_T ibeta;                 /* '<S5>/Gain2' */\r\nextern real32_T state;                 /* '<S2>/Chart1' */\r\n\r\n/* Model entry point functions */\r\nextern void FOC_Model_initialize(void);\r\nextern void FOC_Model_step(void);\r\n\r\n/* Exported data declaration */\r\n\r\n/* Declaration for custom storage class: Struct */\r\nextern curr_kpki_type curr_kpki;\r\nextern motor_type motor;\r\nextern spd_kpki_type spd_kpki;\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL *const rtM;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S18>/Scope' : Unused code path elimination\r\n * Block '<S9>/Scope' : Unused code path elimination\r\n * Block '<S9>/Scope1' : Unused code path elimination\r\n * Block '<S11>/Add1' : Unused code path elimination\r\n * Block '<S11>/Add2' : Unused code path elimination\r\n * Block '<S11>/Constant3' : Unused code path elimination\r\n * Block '<S11>/Mod1' : Unused code path elimination\r\n * Block '<S11>/Product' : Unused code path elimination\r\n * Block '<S11>/Scope' : Unused code path elimination\r\n * Block '<S11>/Scope1' : Unused code path elimination\r\n * Block '<S11>/Scope2' : Unused code path elimination\r\n * Block '<S11>/Scope3' : Unused code path elimination\r\n * Block '<S11>/Scope4' : Unused code path elimination\r\n * Block '<S12>/Scope' : Unused code path elimination\r\n * Block '<S2>/Scope' : Unused code path elimination\r\n * Block '<S2>/Scope1' : Unused code path elimination\r\n * Block '<S2>/Scope3' : Unused code path elimination\r\n * Block '<S15>/Scope' : Unused code path elimination\r\n * Block '<S17>/Reshape1' : Reshape block reduction\r\n * Block '<S17>/Reshape2' : Reshape block reduction\r\n * Block '<S1>/Rate Transition1' : Eliminated since input and output rates are identical\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('BLDC_EKF/FOC_Model')    - opens subsystem BLDC_EKF/FOC_Model\r\n * hilite_system('BLDC_EKF/FOC_Model/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'BLDC_EKF'\r\n * '<S1>'   : 'BLDC_EKF/FOC_Model'\r\n * '<S2>'   : 'BLDC_EKF/FOC_Model/Curr_loop'\r\n * '<S3>'   : 'BLDC_EKF/FOC_Model/Speed_loop'\r\n * '<S4>'   : 'BLDC_EKF/FOC_Model/Curr_loop/Chart1'\r\n * '<S5>'   : 'BLDC_EKF/FOC_Model/Curr_loop/Clark'\r\n * '<S6>'   : 'BLDC_EKF/FOC_Model/Curr_loop/EKF'\r\n * '<S7>'   : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem'\r\n * '<S8>'   : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem1'\r\n * '<S9>'   : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem2'\r\n * '<S10>'  : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem3'\r\n * '<S11>'  : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem4'\r\n * '<S12>'  : 'BLDC_EKF/FOC_Model/Curr_loop/In_park'\r\n * '<S13>'  : 'BLDC_EKF/FOC_Model/Curr_loop/Park'\r\n * '<S14>'  : 'BLDC_EKF/FOC_Model/Curr_loop/SVPWM1'\r\n * '<S15>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller'\r\n * '<S16>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/A'\r\n * '<S17>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/F'\r\n * '<S18>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/K'\r\n * '<S19>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/P'\r\n * '<S20>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/P_pre'\r\n * '<S21>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/X_hat'\r\n * '<S22>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/X_pre'\r\n * '<S23>'  : 'BLDC_EKF/FOC_Model/Curr_loop/EKF/f'\r\n * '<S24>'  : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem4/If Action Subsystem'\r\n * '<S25>'  : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem4/If Action Subsystem1'\r\n * '<S26>'  : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem4/If Action Subsystem2'\r\n * '<S27>'  : 'BLDC_EKF/FOC_Model/Curr_loop/If Action Subsystem4/If Action Subsystem3'\r\n * '<S28>'  : 'BLDC_EKF/FOC_Model/Curr_loop/SVPWM1/InvClark'\r\n * '<S29>'  : 'BLDC_EKF/FOC_Model/Curr_loop/SVPWM1/ei_t'\r\n * '<S30>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1'\r\n * '<S31>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2'\r\n * '<S32>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Anti-windup'\r\n * '<S33>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/D Gain'\r\n * '<S34>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Filter'\r\n * '<S35>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Filter ICs'\r\n * '<S36>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/I Gain'\r\n * '<S37>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Ideal P Gain'\r\n * '<S38>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Ideal P Gain Fdbk'\r\n * '<S39>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Integrator'\r\n * '<S40>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Integrator ICs'\r\n * '<S41>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/N Copy'\r\n * '<S42>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/N Gain'\r\n * '<S43>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/P Copy'\r\n * '<S44>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Parallel P Gain'\r\n * '<S45>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Reset Signal'\r\n * '<S46>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Saturation'\r\n * '<S47>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Saturation Fdbk'\r\n * '<S48>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Sum'\r\n * '<S49>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Sum Fdbk'\r\n * '<S50>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tracking Mode'\r\n * '<S51>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tracking Mode Sum'\r\n * '<S52>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tsamp - Integral'\r\n * '<S53>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tsamp - Ngain'\r\n * '<S54>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/postSat Signal'\r\n * '<S55>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/preSat Signal'\r\n * '<S56>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Anti-windup/Disc. Clamping Parallel'\r\n * '<S57>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S58>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S59>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/D Gain/Disabled'\r\n * '<S60>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Filter/Disabled'\r\n * '<S61>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Filter ICs/Disabled'\r\n * '<S62>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/I Gain/External Parameters'\r\n * '<S63>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Ideal P Gain/Passthrough'\r\n * '<S64>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Ideal P Gain Fdbk/Disabled'\r\n * '<S65>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Integrator/Discrete'\r\n * '<S66>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Integrator ICs/Internal IC'\r\n * '<S67>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/N Copy/Disabled wSignal Specification'\r\n * '<S68>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/N Gain/Disabled'\r\n * '<S69>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/P Copy/Disabled'\r\n * '<S70>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Parallel P Gain/External Parameters'\r\n * '<S71>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Reset Signal/Disabled'\r\n * '<S72>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Saturation/Enabled'\r\n * '<S73>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Saturation Fdbk/Disabled'\r\n * '<S74>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Sum/Sum_PI'\r\n * '<S75>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Sum Fdbk/Disabled'\r\n * '<S76>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tracking Mode/Disabled'\r\n * '<S77>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tracking Mode Sum/Passthrough'\r\n * '<S78>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tsamp - Integral/Passthrough'\r\n * '<S79>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/Tsamp - Ngain/Passthrough'\r\n * '<S80>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/postSat Signal/Forward_Path'\r\n * '<S81>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller1/preSat Signal/Forward_Path'\r\n * '<S82>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Anti-windup'\r\n * '<S83>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/D Gain'\r\n * '<S84>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Filter'\r\n * '<S85>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Filter ICs'\r\n * '<S86>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/I Gain'\r\n * '<S87>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Ideal P Gain'\r\n * '<S88>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Ideal P Gain Fdbk'\r\n * '<S89>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Integrator'\r\n * '<S90>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Integrator ICs'\r\n * '<S91>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/N Copy'\r\n * '<S92>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/N Gain'\r\n * '<S93>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/P Copy'\r\n * '<S94>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Parallel P Gain'\r\n * '<S95>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Reset Signal'\r\n * '<S96>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Saturation'\r\n * '<S97>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Saturation Fdbk'\r\n * '<S98>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Sum'\r\n * '<S99>'  : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Sum Fdbk'\r\n * '<S100>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tracking Mode'\r\n * '<S101>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tracking Mode Sum'\r\n * '<S102>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tsamp - Integral'\r\n * '<S103>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tsamp - Ngain'\r\n * '<S104>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/postSat Signal'\r\n * '<S105>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/preSat Signal'\r\n * '<S106>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Anti-windup/Disc. Clamping Parallel'\r\n * '<S107>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S108>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S109>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/D Gain/Disabled'\r\n * '<S110>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Filter/Disabled'\r\n * '<S111>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Filter ICs/Disabled'\r\n * '<S112>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/I Gain/External Parameters'\r\n * '<S113>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Ideal P Gain/Passthrough'\r\n * '<S114>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Ideal P Gain Fdbk/Disabled'\r\n * '<S115>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Integrator/Discrete'\r\n * '<S116>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Integrator ICs/Internal IC'\r\n * '<S117>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/N Copy/Disabled wSignal Specification'\r\n * '<S118>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/N Gain/Disabled'\r\n * '<S119>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/P Copy/Disabled'\r\n * '<S120>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Parallel P Gain/External Parameters'\r\n * '<S121>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Reset Signal/Disabled'\r\n * '<S122>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Saturation/Enabled'\r\n * '<S123>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Saturation Fdbk/Disabled'\r\n * '<S124>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Sum/Sum_PI'\r\n * '<S125>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Sum Fdbk/Disabled'\r\n * '<S126>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tracking Mode/Disabled'\r\n * '<S127>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tracking Mode Sum/Passthrough'\r\n * '<S128>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tsamp - Integral/Passthrough'\r\n * '<S129>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/Tsamp - Ngain/Passthrough'\r\n * '<S130>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/postSat Signal/Forward_Path'\r\n * '<S131>' : 'BLDC_EKF/FOC_Model/Curr_loop/idq_Controller/PID Controller2/preSat Signal/Forward_Path'\r\n * '<S132>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3'\r\n * '<S133>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Anti-windup'\r\n * '<S134>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/D Gain'\r\n * '<S135>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Filter'\r\n * '<S136>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Filter ICs'\r\n * '<S137>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/I Gain'\r\n * '<S138>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Ideal P Gain'\r\n * '<S139>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Ideal P Gain Fdbk'\r\n * '<S140>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Integrator'\r\n * '<S141>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Integrator ICs'\r\n * '<S142>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/N Copy'\r\n * '<S143>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/N Gain'\r\n * '<S144>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/P Copy'\r\n * '<S145>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Parallel P Gain'\r\n * '<S146>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Reset Signal'\r\n * '<S147>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Saturation'\r\n * '<S148>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Saturation Fdbk'\r\n * '<S149>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Sum'\r\n * '<S150>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Sum Fdbk'\r\n * '<S151>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tracking Mode'\r\n * '<S152>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tracking Mode Sum'\r\n * '<S153>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tsamp - Integral'\r\n * '<S154>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tsamp - Ngain'\r\n * '<S155>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/postSat Signal'\r\n * '<S156>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/preSat Signal'\r\n * '<S157>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Anti-windup/Disc. Clamping Parallel'\r\n * '<S158>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n * '<S159>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n * '<S160>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/D Gain/Disabled'\r\n * '<S161>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Filter/Disabled'\r\n * '<S162>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Filter ICs/Disabled'\r\n * '<S163>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/I Gain/Internal Parameters'\r\n * '<S164>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Ideal P Gain/Passthrough'\r\n * '<S165>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Ideal P Gain Fdbk/Disabled'\r\n * '<S166>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Integrator/Discrete'\r\n * '<S167>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Integrator ICs/Internal IC'\r\n * '<S168>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/N Copy/Disabled wSignal Specification'\r\n * '<S169>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/N Gain/Disabled'\r\n * '<S170>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/P Copy/Disabled'\r\n * '<S171>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Parallel P Gain/Internal Parameters'\r\n * '<S172>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Reset Signal/External Reset'\r\n * '<S173>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Saturation/Enabled'\r\n * '<S174>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Saturation Fdbk/Disabled'\r\n * '<S175>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Sum/Sum_PI'\r\n * '<S176>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Sum Fdbk/Disabled'\r\n * '<S177>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tracking Mode/Disabled'\r\n * '<S178>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tracking Mode Sum/Passthrough'\r\n * '<S179>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tsamp - Integral/Passthrough'\r\n * '<S180>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/Tsamp - Ngain/Passthrough'\r\n * '<S181>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/postSat Signal/Forward_Path'\r\n * '<S182>' : 'BLDC_EKF/FOC_Model/Speed_loop/PID Controller3/preSat Signal/Forward_Path'\r\n */\r\n#endif                                 /* RTW_HEADER_FOC_Model_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_Model_data.c","type":"source","group":"data","path":"C:\\Users\\Jay\\Desktop\\G4\\Simulink\\8.EKF\\BLDC\\BLDC_EKF_MODEL\\FOC_Model_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * File: FOC_Model_data.c\r\n *\r\n * Code generated for Simulink model 'FOC_Model'.\r\n *\r\n * Model version                  : 2.183\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sun Oct 22 20:56:15 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"FOC_Model.h\"\r\n\r\n/* Invariant block signals (default storage) */\r\nconst ConstB rtConstB = {\r\n  /* Start of '<S1>/Curr_loop' */\r\n  {\r\n    { 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F }/* '<S18>/Transpose' */\r\n  }\r\n  /* End of '<S1>/Curr_loop' */\r\n};\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP rtConstP = {\r\n  /* Computed Parameter: B_Value\r\n   * Referenced by: '<S6>/B'\r\n   */\r\n  { 186.915894F, 0.0F, 0.0F, 0.0F, 0.0F, 186.915894F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: H_Value\r\n   * Referenced by: '<S6>/H'\r\n   */\r\n  { 1.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F },\r\n\r\n  /* Computed Parameter: Q_Value\r\n   * Referenced by: '<S6>/Q'\r\n   */\r\n  { 0.001F, 0.0F, 0.0F, 0.0F, 0.0F, 0.1F, 0.0F, 0.0F, 0.0F, 0.0F, 10.0F, 0.0F,\r\n    0.0F, 0.0F, 0.0F, 0.01F },\r\n\r\n  /* Computed Parameter: R_Value\r\n   * Referenced by: '<S6>/R'\r\n   */\r\n  { 0.1F, 0.0F, 0.0F, 0.1F },\r\n\r\n  /* Pooled Parameter (Expression: )\r\n   * Referenced by:\r\n   *   '<S16>/IdentityMatrix'\r\n   *   '<S19>/IdentityMatrix'\r\n   */\r\n  { 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F, 0.0F, 0.0F, 1.0F, 0.0F, 0.0F,\r\n    0.0F, 0.0F, 1.0F }\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\Jay\\Desktop\\G4\\Simulink\\8.EKF\\BLDC\\BLDC_EKF_MODEL\\FOC_Model_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'FOC_Model'.\r\n *\r\n * Model version                  : 2.183\r\n * Simulink Coder version         : 9.6 (R2021b) 14-May-2021\r\n * C/C++ source code generated on : Sun Oct 22 20:56:15 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex-M\r\n * Code generation objectives:\r\n *    1. Execution efficiency\r\n *    2. RAM efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex-M\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32    long long:  64\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mw_cmsis.h","type":"header","group":"other","path":"C:\\Users\\Jay\\Desktop\\G4\\Simulink\\8.EKF\\BLDC\\BLDC_EKF_MODEL\\FOC_Model_ert_rtw","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2021 The MathWorks, Inc. */\r\n\r\n/****************************************************\r\n*                                                   *   \r\n* Wrapper functions for CMSIS functions             *\r\n*                                                   *  \r\n****************************************************/\r\n\r\n#ifndef MW_CMSIS_H\r\n#define MW_CMSIS_H\r\n\r\n#include \"arm_math.h\"\r\n#include \"rtwtypes.h\"\r\n\r\n#define mw_arm_abs_f32(pSrc, pDst, blockSize) arm_abs_f32((float32_t *)pSrc, (float32_t *)pDst, blockSize)\r\n#define mw_arm_abs_q7(pSrc, pDst, blockSize) arm_abs_q7((q7_t *)pSrc, (q7_t *)pDst, blockSize) \r\n#define mw_arm_abs_q15(pSrc, pDst, blockSize) arm_abs_q15((q15_t *)pSrc, (q15_t *)pDst, blockSize) \r\n#define mw_arm_abs_q31(pSrc, pDst, blockSize) arm_abs_q31((q31_t *)pSrc, (q31_t *)pDst, blockSize) \r\n\r\n#define mw_arm_sqrt_q15(in, pOut) arm_sqrt_q15((q15_t)in,(q15_t *)pOut)\r\n#define mw_arm_sqrt_q31(in, pOut) arm_sqrt_q31((q31_t)in,(q31_t *)pOut)\r\n#define mw_arm_sqrt_f32(in, pOut) arm_sqrt_f32((float32_t)in,(float32_t *)pOut)\r\n\r\n#define mw_arm_float_to_q31(pSrc, pDst, blockSize) arm_float_to_q31((float32_t *)pSrc, (q31_t *)pDst, blockSize)\r\n#define mw_arm_float_to_q15(pSrc, pDst, blockSize) arm_float_to_q15((float32_t *)pSrc, (q15_t *)pDst, blockSize)\r\n#define mw_arm_float_to_q7(pSrc, pDst, blockSize) arm_float_to_q7((float32_t *)pSrc, (q7_t *)pDst, blockSize)\r\n\r\n#define mw_arm_q15_to_float(pSrc, pDst, blockSize) arm_q15_to_float((q15_t *)pSrc, (float32_t *)pDst, blockSize)\r\n#define mw_arm_q15_to_q31(pSrc, pDst, blockSize) arm_q15_to_q31((q15_t *)pSrc, (q31_t *)pDst, blockSize)\r\n#define mw_arm_q15_to_q7(pSrc, pDst, blockSize) arm_q15_to_q7((q15_t *)pSrc, (q7_t *)pDst, blockSize)\r\n\r\n#define mw_arm_q31_to_float(pSrc, pDst, blockSize) arm_q31_to_float((q31_t *)pSrc, (float32_t *)pDst, blockSize)\r\n#define mw_arm_q31_to_q15(pSrc, pDst, blockSize) arm_q31_to_q15((q31_t *)pSrc, (q15_t *)pDst, blockSize)\r\n#define mw_arm_q31_to_q7(pSrc, pDst, blockSize) arm_q31_to_q7((q31_t *)pSrc, (q7_t *)pDst, blockSize)\r\n\r\n#define mw_arm_q7_to_float(pSrc, pDst, blockSize) arm_q7_to_float((q7_t *)pSrc, (float32_t *)pDst, blockSize)\r\n#define mw_arm_q7_to_q31(pSrc, pDst, blockSize) arm_q7_to_q31((q7_t *)pSrc, (q31_t *)pDst, blockSize)\r\n#define mw_arm_q7_to_q15(pSrc, pDst, blockSize) arm_q7_to_q15((q7_t *)pSrc, (q15_t *)pDst, blockSize)\r\n\r\n#define mw_arm_add_f32(pSrcA, pSrcB, pDst, blockSize) arm_add_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\r\n#define mw_arm_add_q31(pSrcA, pSrcB, pDst, blockSize) arm_add_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\r\n#define mw_arm_add_q15(pSrcA, pSrcB, pDst, blockSize) arm_add_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\r\n#define mw_arm_add_q7(pSrcA, pSrcB, pDst, blockSize)  arm_add_q7((q7_t *)pSrcA, (q7_t *)pSrcB, (q7_t *)pDst, blockSize)\r\n\r\n#define mw_arm_sub_f32(pSrcA, pSrcB, pDst, blockSize) arm_sub_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\r\n#define mw_arm_sub_q31(pSrcA, pSrcB, pDst, blockSize) arm_sub_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\r\n#define mw_arm_sub_q15(pSrcA, pSrcB, pDst, blockSize) arm_sub_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\r\n#define mw_arm_sub_q7(pSrcA, pSrcB, pDst, blockSize)  arm_sub_q7((q7_t *)pSrcA, (q7_t *)pSrcB, (q7_t *)pDst, blockSize)\r\n\r\n#define mw_arm_mult_f32(pSrcA, pSrcB, pDst, blockSize) arm_mult_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\r\n#define mw_arm_mult_q31(pSrcA, pSrcB, pDst, blockSize) arm_mult_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\r\n#define mw_arm_mult_q15(pSrcA, pSrcB, pDst, blockSize) arm_mult_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\r\n#define mw_arm_mult_q7(pSrcA, pSrcB, pDst, blockSize)  arm_mult_q7((q7_t *)pSrcA, (q7_t *)pSrcB, (q7_t *)pDst, blockSize)\r\n\r\n#define mw_arm_cmplx_conj_f32(pSrc, pDst, numSamples) arm_cmplx_conj_f32((float32_t *)pSrc, (float32_t *)pDst, numSamples)\r\n#define mw_arm_cmplx_conj_q31(pSrc, pDst, numSamples) arm_cmplx_conj_q31((q31_t *)pSrc, (q31_t *)pDst, numSamples)\r\n#define mw_arm_cmplx_conj_q15(pSrc, pDst, numSamples) arm_cmplx_conj_q15((q15_t *)pSrc, (q15_t *)pDst, numSamples)\r\n\r\n#define mw_arm_cmplx_mult_cmplx_f32(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_cmplx_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\r\n#define mw_arm_cmplx_mult_cmplx_q31(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_cmplx_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\r\n#define mw_arm_cmplx_mult_cmplx_q15(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_cmplx_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\r\n\r\n#define mw_arm_cmplx_mult_real_f32(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_real_f32((float32_t *)pSrcA, (float32_t *)pSrcB, (float32_t *)pDst, blockSize)\r\n#define mw_arm_cmplx_mult_real_q31(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_real_q31((q31_t *)pSrcA, (q31_t *)pSrcB, (q31_t *)pDst, blockSize)\r\n#define mw_arm_cmplx_mult_real_q15(pSrcA, pSrcB, pDst, blockSize) arm_cmplx_mult_real_q15((q15_t *)pSrcA, (q15_t *)pSrcB, (q15_t *)pDst, blockSize)\r\n\r\n#define mw_arm_rshift_q15(pSrc, shiftBits, pDst, blockSize) arm_shift_q15 ((q15_t *)pSrc, -(shiftBits),(q15_t *)pDst, blockSize)\r\n#define mw_arm_rshift_q31(pSrc, shiftBits, pDst, blockSize) arm_shift_q31 ((q31_t *)pSrc, -(shiftBits), (q31_t *)pDst, blockSize)\r\n#define mw_arm_rshift_q7(pSrc, shiftBits, pDst, blockSize) arm_shift_q7 ((q7_t *)pSrc,  -(shiftBits), (q7_t *)pDst, blockSize)\r\n\r\n#define mw_arm_shift_q15(pSrc, shiftBits, pDst, blockSize) arm_shift_q15 ((q15_t *)pSrc, shiftBits,(q15_t *)pDst, blockSize)\r\n#define mw_arm_shift_q31(pSrc, shiftBits, pDst, blockSize) arm_shift_q31 ((q31_t *)pSrc, shiftBits, (q31_t *)pDst, blockSize)\r\n#define mw_arm_shift_q7(pSrc, shiftBits, pDst, blockSize) arm_shift_q7 ((q7_t *)pSrc, shiftBits, (q7_t *)pDst, blockSize)\r\n\r\n#endif\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};